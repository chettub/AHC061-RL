// exp002 submit (compact int8/fp16, no torch runtime)
// NOTE: This file is NOT a single-file submission by itself.
// Use make_submit_compact.py to bundle local headers + embed the model.

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <limits>
#include <string_view>
#include <vector>

#include <immintrin.h>

#include "ahc061/core/adf_beta_estimator.hpp"
#include "ahc061/core/opponent_ai_dist.hpp"
#include "ahc061/core/rules_moves.hpp"
#include "ahc061/core/state.hpp"

// GENERATED by make_submit_compact.py (feature-specific).
#include "model_compact_encoded.inc"

namespace ahc061::exp002 {
using std::int64_t;
using std::int8_t;
using std::size_t;
using std::uint16_t;
using std::uint8_t;
template <class T, size_t N>
using A = std::array<T, N>;
template <class T>
using V = std::vector<T>;
using SV = std::string_view;

static constexpr int HIDDEN_C = 112;
static constexpr int BLOCKS_N = 16;
static constexpr int IN_CHANNELS = 149;
static constexpr int PLAYER_HIDDEN_C = 56;
static constexpr int FRONT_BLOCKS_N = (BLOCKS_N / 2 > 0) ? (BLOCKS_N / 2) : 1;
static constexpr int BACK_BLOCKS_N = BLOCKS_N - FRONT_BLOCKS_N;

static constexpr int R4_GLOBAL_C = 19;
static constexpr int R4_PLAYER_PER_C = 16;
static constexpr int R4_PLAYER_BLOCK_C = M_MAX * R4_PLAYER_PER_C;
static constexpr int R4_TOTAL_C = R4_GLOBAL_C + R4_PLAYER_BLOCK_C + 2;
static constexpr int FEATURE_INPUT_C = R4_TOTAL_C;
static constexpr int PLAYER_BRANCH_N = M_MAX - 1;
static constexpr int PLAYER_COMMON_INPUT_C = R4_GLOBAL_C + R4_PLAYER_PER_C;
static constexpr int PLAYER_ENEMY_FEAT_INPUT_C = R4_PLAYER_PER_C;

inline int pc(int np, int offset) { return 19 + np * 16 + offset; }

static V<uint8_t> b91d(SV s) {
    static constexpr std::array<std::int16_t, 256> kDec = [] {
        std::array<std::int16_t, 256> t{};
        t.fill(-1);
        int idx = 0;
        for (int c = 1; c <= 31; c++) {
            if (c == 10 || c == 13)
                continue;
            t[static_cast<std::uint8_t>(c)] = static_cast<std::int16_t>(idx++);
        }
        for (int c = 32; c <= 127; c++) {
            t[static_cast<std::uint8_t>(c)] = static_cast<std::int16_t>(idx++);
        }
        return t;
    }();

    V<uint8_t> out;
    out.reserve(s.size() * 13 / 16 + 8);
    int v = -1;
    std::uint32_t b = 0;
    int n = 0;
    for (unsigned char uc : s) {
        const int d = static_cast<int>(kDec[uc]);
        if (d < 0)
            continue;
        if (v < 0) {
            v = d;
            continue;
        }
        const int val = v + d * 125;
        b |= static_cast<std::uint32_t>(val) << n;
        n += ((val & 8191) < 7433) ? 14 : 13;
        while (n > 7) {
            out.push_back(static_cast<uint8_t>(b & 0xFFU));
            b >>= 8;
            n -= 8;
        }
        v = -1;
    }
    if (v >= 0) {
        out.push_back(static_cast<uint8_t>((b | (static_cast<std::uint32_t>(v) << n)) & 0xFFU));
    }
    return out;
}

static V<uint8_t> hfd(const V<uint8_t>& blob, size_t expected_size) {
    V<uint8_t> out(expected_size);
    if (expected_size == 0)
        return out;

    struct SymLen {
        uint16_t sym;
        uint8_t len;
    };
    V<SymLen> syms;
    syms.reserve(256);
    for (int s = 0; s < 256; s++) {
        const uint8_t by = blob[static_cast<size_t>(s >> 1)];
        const uint8_t ln = ((s & 1) == 0) ? static_cast<uint8_t>(by & 0x0FU)
                                         : static_cast<uint8_t>(by >> 4);
        if (ln > 0) {
            syms.push_back(SymLen{static_cast<uint16_t>(s), ln});
        }
    }

    std::sort(syms.begin(), syms.end(), [](const SymLen& a, const SymLen& b) {
        if (a.len != b.len)
            return a.len < b.len;
        return a.sym < b.sym;
    });

    V<int> left(1, -1), right(1, -1), value(1, -1);
    std::uint64_t code = 0;
    int prev_len = 0;
    for (const SymLen sl : syms) {
        const int ln = static_cast<int>(sl.len);
        code <<= static_cast<std::uint64_t>(ln - prev_len);
        int node = 0;
        for (int k = ln - 1; k >= 0; k--) {
            const int bit = static_cast<int>((code >> static_cast<unsigned>(k)) & 1ULL);
            int nxt = bit ? right[node] : left[node];
            if (nxt < 0) {
                nxt = static_cast<int>(value.size());
                left.push_back(-1);
                right.push_back(-1);
                value.push_back(-1);
                if (bit) {
                    right[node] = nxt;
                } else {
                    left[node] = nxt;
                }
            }
            node = nxt;
        }
        value[node] = static_cast<int>(sl.sym);
        code += 1ULL;
        prev_len = ln;
    }

    size_t out_i = 0;
    int node = 0;
    for (size_t i = 128ULL; i < blob.size(); i++) {
        const uint8_t by = blob[i];
        for (int k = 7; k >= 0; k--) {
            const int bit = static_cast<int>((by >> static_cast<unsigned>(k)) & 1U);
            node = bit ? right[node] : left[node];
            const int sym = value[node];
            if (sym >= 0) {
                out[out_i++] = static_cast<uint8_t>(sym);
                if (out_i == expected_size)
                    return out;
                node = 0;
            }
        }
    }
    return out;
}

static V<uint8_t> dpl(SV s, size_t expected_size) {
    const V<uint8_t> packed = b91d(s);
    return hfd(packed, expected_size);
}

static float h2f(uint16_t h) {
    const std::uint32_t sign = static_cast<std::uint32_t>(h & 0x8000U) << 16;
    std::uint32_t exp = static_cast<std::uint32_t>((h >> 10) & 0x1FU);
    std::uint32_t frac = static_cast<std::uint32_t>(h & 0x03FFU);
    std::uint32_t f = 0;

    if (exp == 0) {
        if (frac == 0) {
            f = sign;
        } else {
            exp = 1;
            while ((frac & 0x0400U) == 0U) {
                frac <<= 1;
                exp--;
            }
            frac &= 0x03FFU;
            f = sign | ((exp + 112U) << 23) | (frac << 13);
        }
    } else if (exp == 31) {
        f = sign | 0x7F800000U | (frac << 13);
    } else {
        f = sign | ((exp + 112U) << 23) | (frac << 13);
    }

    float out = 0.0F;
    std::memcpy(&out, &f, sizeof(float));
    return out;
}

static int pggs(int channels) {
    for (int g : {8, 4, 2, 1}) {
        if (channels % g == 0)
            return g;
    }
    return 1;
}

struct CM {
    int ic = 0;
    int h = 0;
    int b = 0;
    int fb = 0;
    int bb = 0;
    int ph = 0;
    int gg = 1;
    int pgg = 1;

    V<float> msw;    // [C][H] (transposed)
    V<float> msgw; // [H]
    V<float> msgb; // [H]

    V<float> mfdw;    // [F][H][9]
    V<float> mfdgw; // [F][H]
    V<float> mfdgb; // [F][H]
    V<float> mfpw;    // [F][H][H] transposed
    V<float> mfpgw; // [F][H]
    V<float> mfpgb; // [F][H]

    V<float> mbdw;    // [B][H][9]
    V<float> mbdgw; // [B][H]
    V<float> mbdgb; // [B][H]
    V<float> mbpw;    // [B][H][H] transposed
    V<float> mbpgw; // [B][H]
    V<float> mbpgb; // [B][H]

    V<float> pscw; // [35][PH] transposed
    V<float> psew;  // [16][PH] transposed
    V<float> peid;      // [7][PH]
    V<float> psgw;     // [PH]
    V<float> psgb;     // [PH]

    V<float> pfdw;    // [F][PH][9]
    V<float> pfdgw; // [F][PH]
    V<float> pfdgb; // [F][PH]
    V<float> pfpw;    // [F][PH][PH] transposed
    V<float> pfpgw; // [F][PH]
    V<float> pfpgb; // [F][PH]

    V<float> mmw;   // [H][H] transposed
    V<float> mpw; // [7*PH][H] transposed
    V<float> mgw;     // [H]
    V<float> mgb;     // [H]

    V<float> pw; // [H]
    float pb = 0.0F;
};

static CM lcm() {
    const V<uint8_t> q_bytes = dpl(SV(Q, sizeof(Q) - 1ULL), QB);
    const V<uint8_t> h_bytes = dpl(SV(H, sizeof(H) - 1ULL), HB);

    CM model{};
    model.ic = IN_CHANNELS;
    model.h = HIDDEN_C;
    model.b = BLOCKS_N;
    model.fb = FRONT_BLOCKS_N;
    model.bb = BACK_BLOCKS_N;
    model.ph = PLAYER_HIDDEN_C;
    model.gg = pggs(model.h);
    model.pgg = pggs(model.ph);

    const size_t h = static_cast<size_t>(model.h);
    const size_t ph = static_cast<size_t>(model.ph);
    const size_t f = static_cast<size_t>(model.fb);
    const size_t bk = static_cast<size_t>(model.bb);
    const size_t c = static_cast<size_t>(model.ic);

    model.msw.resize(c * h);
    model.msgw.resize(h);
    model.msgb.resize(h);

    model.mfdw.resize(f * h * 9ULL);
    model.mfdgw.resize(f * h);
    model.mfdgb.resize(f * h);
    model.mfpw.resize(f * h * h);
    model.mfpgw.resize(f * h);
    model.mfpgb.resize(f * h);

    model.mbdw.resize(bk * h * 9ULL);
    model.mbdgw.resize(bk * h);
    model.mbdgb.resize(bk * h);
    model.mbpw.resize(bk * h * h);
    model.mbpgw.resize(bk * h);
    model.mbpgb.resize(bk * h);

    model.pscw.resize(static_cast<size_t>(PLAYER_COMMON_INPUT_C) * ph);
    model.psew.resize(static_cast<size_t>(PLAYER_ENEMY_FEAT_INPUT_C) * ph);
    model.peid.resize(static_cast<size_t>(PLAYER_BRANCH_N) * ph);
    model.psgw.resize(ph);
    model.psgb.resize(ph);

    model.pfdw.resize(f * ph * 9ULL);
    model.pfdgw.resize(f * ph);
    model.pfdgb.resize(f * ph);
    model.pfpw.resize(f * ph * ph);
    model.pfpgw.resize(f * ph);
    model.pfpgb.resize(f * ph);

    model.mmw.resize(h * h);
    model.mpw.resize(static_cast<size_t>(PLAYER_BRANCH_N) * ph * h);
    model.mgw.resize(h);
    model.mgb.resize(h);
    model.pw.resize(h);

    size_t q_off = 0;
    size_t h_off = 0;  // byte offset

    const auto read_h = [&]() -> float {
        const uint16_t bits = static_cast<uint16_t>(h_bytes[h_off]) |
                                   (static_cast<uint16_t>(h_bytes[h_off + 1]) << 8);
        h_off += 2;
        return h2f(bits);
    };

    const auto read_q_i8_block = [&](V<float>& dst, size_t off, size_t out_c, size_t in_c) {
        V<float> scale(out_c);
        for (size_t oc = 0; oc < out_c; oc++) scale[oc] = read_h();
        for (size_t oc = 0; oc < out_c; oc++) {
            const float s = scale[oc];
            for (size_t ic = 0; ic < in_c; ic++) {
                const int8_t qv = static_cast<int8_t>(q_bytes[q_off++]);
                dst[off + ic * out_c + oc] = static_cast<float>(qv) * s;
            }
        }
    };
    const auto read_aux_vec = [&](V<float>& dst, size_t off, size_t n) {
        for (size_t i = 0; i < n; i++) dst[off + i] = read_h();
    };
    const auto read_dw_kernel = [&](V<float>& dst, size_t ch, size_t block_idx) {
        const size_t bo = block_idx * ch;
        for (size_t ci = 0; ci < ch; ci++) {
            const size_t base = (bo + ci) * 9ULL;
            for (size_t k = 0; k < 9; k++) dst[base + k] = read_h();
        }
    };

    read_aux_vec(model.msw, 0, c * h);
    read_aux_vec(model.msgw, 0, h);
    read_aux_vec(model.msgb, 0, h);

    for (size_t bi = 0; bi < f; bi++) {
        const size_t bo = bi * h;
        const size_t bo_pw = bi * h * h;
        read_dw_kernel(model.mfdw, h, bi);
        read_aux_vec(model.mfdgw, bo, h);
        read_aux_vec(model.mfdgb, bo, h);
        read_q_i8_block(model.mfpw, bo_pw, h, h);
        read_aux_vec(model.mfpgw, bo, h);
        read_aux_vec(model.mfpgb, bo, h);
    }

    for (size_t bi = 0; bi < bk; bi++) {
        const size_t bo = bi * h;
        const size_t bo_pw = bi * h * h;
        read_dw_kernel(model.mbdw, h, bi);
        read_aux_vec(model.mbdgw, bo, h);
        read_aux_vec(model.mbdgb, bo, h);
        read_q_i8_block(model.mbpw, bo_pw, h, h);
        read_aux_vec(model.mbpgw, bo, h);
        read_aux_vec(model.mbpgb, bo, h);
    }

    read_aux_vec(model.pscw, 0, static_cast<size_t>(PLAYER_COMMON_INPUT_C) * ph);
    read_aux_vec(model.psew, 0, static_cast<size_t>(PLAYER_ENEMY_FEAT_INPUT_C) * ph);
    read_aux_vec(model.peid, 0, static_cast<size_t>(PLAYER_BRANCH_N) * ph);
    read_aux_vec(model.psgw, 0, ph);
    read_aux_vec(model.psgb, 0, ph);

    for (size_t bi = 0; bi < f; bi++) {
        const size_t bo = bi * ph;
        const size_t bo_dw = bo * 9ULL;
        const size_t bo_pw = bi * ph * ph;
        read_aux_vec(model.pfdw, bo_dw, ph * 9ULL);
        read_aux_vec(model.pfdgw, bo, ph);
        read_aux_vec(model.pfdgb, bo, ph);
        read_q_i8_block(model.pfpw, bo_pw, ph, ph);
        read_aux_vec(model.pfpgw, bo, ph);
        read_aux_vec(model.pfpgb, bo, ph);
    }
    read_q_i8_block(model.mmw, 0, h, h);
    read_q_i8_block(model.mpw, 0, h, static_cast<size_t>(PLAYER_BRANCH_N) * ph);
    read_aux_vec(model.mgw, 0, h);
    read_aux_vec(model.mgb, 0, h);
    read_aux_vec(model.pw, 0, h);
    model.pb = read_h();

    return model;
}

static constexpr int kSiluLutSize = 16385;
static constexpr float kSiluLutRange = 16.0F;
static constexpr float kSiluLutMin = -kSiluLutRange;
static constexpr float kSiluLutMax = kSiluLutRange;
static const A<float, kSiluLutSize>& slt() {
    static const A<float, kSiluLutSize> lut = [] {
        A<float, kSiluLutSize> t{};
        for (int i = 0; i < kSiluLutSize; i++) {
            const float x0 = kSiluLutMin +
                             (kSiluLutMax - kSiluLutMin) * static_cast<float>(i) / static_cast<float>(kSiluLutSize - 1);
            t[static_cast<size_t>(i)] = 1.0F / (1.0F + std::exp(-x0));
        }
        return t;
    }();
    return lut;
}
static inline float sls(float x) {
    const auto& lut = slt();
    if (x <= kSiluLutMin)
        return x * lut[0];
    if (x >= kSiluLutMax)
        return x * lut[kSiluLutSize - 1];
    const float pos = (x - kSiluLutMin) * static_cast<float>(kSiluLutSize - 1) / (kSiluLutMax - kSiluLutMin);
    const int idx = static_cast<int>(pos);
    const float frac = pos - static_cast<float>(idx);
    const float s0 = lut[static_cast<size_t>(idx)];
    const float s1 = lut[static_cast<size_t>(idx + 1)];
    return x * (s0 + (s1 - s0) * frac);
}

static inline float silu(float x) {
    return sls(x);
}


// 1x1 conv using rank-1 accumulation:
// out[oc, idx] = sum_ic in[ic, idx] * w_t[ic, oc]
__attribute__((target("avx2,fma")))
static void c1a(const float* in, int in_c, int out_channels, const float* w_t, float* out) {
    constexpr int kVec = (CELL_MAX / 8) * 8;
    for (int oc = 0; oc < out_channels; oc += 8) {
        float* d0 = out + static_cast<size_t>(oc + 0) * CELL_MAX;
        float* d1 = out + static_cast<size_t>(oc + 1) * CELL_MAX;
        float* d2 = out + static_cast<size_t>(oc + 2) * CELL_MAX;
        float* d3 = out + static_cast<size_t>(oc + 3) * CELL_MAX;
        float* d4 = out + static_cast<size_t>(oc + 4) * CELL_MAX;
        float* d5 = out + static_cast<size_t>(oc + 5) * CELL_MAX;
        float* d6 = out + static_cast<size_t>(oc + 6) * CELL_MAX;
        float* d7 = out + static_cast<size_t>(oc + 7) * CELL_MAX;
        int i = 0;
        for (; i < kVec; i += 8) {
            __m256 acc0 = _mm256_setzero_ps();
            __m256 acc1 = _mm256_setzero_ps();
            __m256 acc2 = _mm256_setzero_ps();
            __m256 acc3 = _mm256_setzero_ps();
            __m256 acc4 = _mm256_setzero_ps();
            __m256 acc5 = _mm256_setzero_ps();
            __m256 acc6 = _mm256_setzero_ps();
            __m256 acc7 = _mm256_setzero_ps();
            for (int ic = 0; ic < in_c; ic++) {
                const float* src = in + static_cast<size_t>(ic) * CELL_MAX + i;
                const float* wr = w_t + static_cast<size_t>(ic) * static_cast<size_t>(out_channels) + oc;
                const __m256 s = _mm256_loadu_ps(src);
                acc0 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[0]), acc0);
                acc1 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[1]), acc1);
                acc2 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[2]), acc2);
                acc3 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[3]), acc3);
                acc4 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[4]), acc4);
                acc5 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[5]), acc5);
                acc6 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[6]), acc6);
                acc7 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[7]), acc7);
            }
            _mm256_storeu_ps(d0 + i, acc0);
            _mm256_storeu_ps(d1 + i, acc1);
            _mm256_storeu_ps(d2 + i, acc2);
            _mm256_storeu_ps(d3 + i, acc3);
            _mm256_storeu_ps(d4 + i, acc4);
            _mm256_storeu_ps(d5 + i, acc5);
            _mm256_storeu_ps(d6 + i, acc6);
            _mm256_storeu_ps(d7 + i, acc7);
        }
        for (; i < CELL_MAX; i++) {
            float s[8]{};
            float* d[8]{d0, d1, d2, d3, d4, d5, d6, d7};
            for (int ic = 0; ic < in_c; ic++) {
                const float v = in[static_cast<size_t>(ic) * CELL_MAX + i];
                const float* wr = w_t + static_cast<size_t>(ic) * static_cast<size_t>(out_channels) + oc;
                for (int j = 0; j < 8; j++) s[j] += v * wr[j];
            }
            for (int j = 0; j < 8; j++) d[j][i] = s[j];
        }
    }
}

__attribute__((target("avx2,fma")))
static void pla(const float* x, int channels, const float* w, float bias, float* ol) {
    constexpr int kVec = (CELL_MAX / 8) * 8;
    const __m256 vbias = _mm256_set1_ps(bias);
    int i = 0;
    for (; i < kVec; i += 8) {
        _mm256_storeu_ps(ol + i, vbias);
    }
    for (; i < CELL_MAX; i++) {
        ol[i] = bias;
    }

    for (int c = 0; c < channels; c++) {
        const float wc = w[static_cast<size_t>(c)];
        const __m256 vw = _mm256_set1_ps(wc);
        const float* src = x + static_cast<size_t>(c) * CELL_MAX;
        int j = 0;
        for (; j < kVec; j += 8) {
            __m256 o = _mm256_loadu_ps(ol + j);
            const __m256 s = _mm256_loadu_ps(src + j);
            o = _mm256_fmadd_ps(s, vw, o);
            _mm256_storeu_ps(ol + j, o);
        }
        for (; j < CELL_MAX; j++) {
            ol[j] += src[j] * wc;
        }
    }
}

static inline float d3c(const float* src, const float* wc, int x, int y) {
    float s = 0.0F;
    int k = 0;
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            const int xx = x + dx;
            const int yy = y + dy;
            if (0 <= xx && xx < N && 0 <= yy && yy < N) {
                s += src[cell_index(xx, yy)] * wc[k];
            }
            k++;
        }
    }
    return s;
}

__attribute__((target("avx2,fma")))
static inline float hs8(__m256 v) {
    alignas(32) float tmp[8];
    _mm256_store_ps(tmp, v);
    return tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7];
}

__attribute__((target("avx2,fma")))
static void d3a(const float* in, int channels, const float* w, float* out) {
    for (int c = 0; c < channels; c++) {
        const float* wc = w + static_cast<size_t>(c) * 9ULL;
        const float* src = in + static_cast<size_t>(c) * CELL_MAX;
        float* dst = out + static_cast<size_t>(c) * CELL_MAX;

        for (int y = 0; y < N; y++) {
            dst[y] = d3c(src, wc, 0, y);
            dst[(N - 1) * N + y] = d3c(src, wc, N - 1, y);
        }

        const __m256 w0 = _mm256_set1_ps(wc[0]);
        const __m256 w1 = _mm256_set1_ps(wc[1]);
        const __m256 w2 = _mm256_set1_ps(wc[2]);
        const __m256 w3 = _mm256_set1_ps(wc[3]);
        const __m256 w4 = _mm256_set1_ps(wc[4]);
        const __m256 w5 = _mm256_set1_ps(wc[5]);
        const __m256 w6 = _mm256_set1_ps(wc[6]);
        const __m256 w7 = _mm256_set1_ps(wc[7]);
        const __m256 w8 = _mm256_set1_ps(wc[8]);

        for (int x = 1; x < N - 1; x++) {
            const int row = x * N;
            dst[row] = d3c(src, wc, x, 0);

            int y = 1;
            for (; y + 7 < N - 1; y += 8) {
                const int top = (x - 1) * N + (y - 1);
                const int mid = x * N + (y - 1);
                const int bot = (x + 1) * N + (y - 1);

                __m256 s = _mm256_setzero_ps();
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 0), w0, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 1), w1, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 2), w2, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 0), w3, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 1), w4, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 2), w5, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 0), w6, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 1), w7, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 2), w8, s);
                _mm256_storeu_ps(dst + row + y, s);
            }
            for (; y < N - 1; y++) {
                const int idx = row + y;
                dst[idx] = src[idx - N - 1] * wc[0] + src[idx - N] * wc[1] + src[idx - N + 1] * wc[2] +
                           src[idx - 1] * wc[3] + src[idx] * wc[4] + src[idx + 1] * wc[5] +
                           src[idx + N - 1] * wc[6] + src[idx + N] * wc[7] + src[idx + N + 1] * wc[8];
            }

            dst[row + (N - 1)] = d3c(src, wc, x, N - 1);
        }
    }
}

__attribute__((target("avx2,fma")))
static inline __m256 sva(__m256 x) {
    const auto& lut = slt();
    const float* lut_ptr = lut.data();
    const __m256 vmin = _mm256_set1_ps(kSiluLutMin);
    const __m256 vmax = _mm256_set1_ps(kSiluLutMax);
    const __m256 vscale = _mm256_set1_ps(static_cast<float>(kSiluLutSize - 1) / (kSiluLutMax - kSiluLutMin));
    __m256 xc = _mm256_min_ps(vmax, _mm256_max_ps(vmin, x));
    __m256 pos = _mm256_mul_ps(_mm256_sub_ps(xc, vmin), vscale);
    __m256 pos_floor = _mm256_floor_ps(pos);
    __m256i idx = _mm256_cvttps_epi32(pos_floor);
    idx = _mm256_min_epi32(idx, _mm256_set1_epi32(kSiluLutSize - 2));
    __m256 frac = _mm256_sub_ps(pos, _mm256_cvtepi32_ps(idx));
    __m256 s0 = _mm256_i32gather_ps(lut_ptr, idx, 4);
    __m256 s1 = _mm256_i32gather_ps(lut_ptr, _mm256_add_epi32(idx, _mm256_set1_epi32(1)), 4);
    __m256 s = _mm256_fmadd_ps(_mm256_sub_ps(s1, s0), frac, s0);
    return _mm256_mul_ps(x, s);
}

__attribute__((target("avx2,fma")))
static void gna(
    const float* in,
    int channels,
    int groups,
    const float* gn_w,
    const float* gn_b,
    float* out,
    bool apply_silu) {
    const int c_per_group = channels / groups;
    constexpr float kEps = 1.0e-5F;
    constexpr int kVec = (CELL_MAX / 8) * 8;

    for (int g = 0; g < groups; g++) {
        const int c0 = g * c_per_group;
        const int c1 = c0 + c_per_group;

        __m256 sum_v = _mm256_setzero_ps();
        __m256 sq_v = _mm256_setzero_ps();
        float sum_tail = 0.0F;
        float sq_tail = 0.0F;
        for (int c = c0; c < c1; c++) {
            const float* src = in + static_cast<size_t>(c) * CELL_MAX;
            int i = 0;
            for (; i < kVec; i += 8) {
                const __m256 v = _mm256_loadu_ps(src + i);
                sum_v = _mm256_add_ps(sum_v, v);
                sq_v = _mm256_fmadd_ps(v, v, sq_v);
            }
            for (; i < CELL_MAX; i++) {
                const float v = src[i];
                sum_tail += v;
                sq_tail += v * v;
            }
        }

        float sum = hs8(sum_v) + sum_tail;
        float sq = hs8(sq_v) + sq_tail;
        const float inv_n = 1.0F / static_cast<float>(c_per_group * CELL_MAX);
        const float mean = sum * inv_n;
        float var = sq * inv_n - mean * mean;
        if (var < 0.0F)
            var = 0.0F;
        const float inv_std = 1.0F / std::sqrt(var + kEps);

        const __m256 vmean = _mm256_set1_ps(mean);
        const __m256 vstd = _mm256_set1_ps(inv_std);
        for (int c = c0; c < c1; c++) {
            const float gw = gn_w[c];
            const float gb = gn_b[c];
            const float* src = in + static_cast<size_t>(c) * CELL_MAX;
            float* dst = out + static_cast<size_t>(c) * CELL_MAX;

            if (apply_silu) {
                const __m256 vgw = _mm256_set1_ps(gw);
                const __m256 vgb = _mm256_set1_ps(gb);
                int i = 0;
                for (; i < kVec; i += 8) {
                    __m256 v = _mm256_loadu_ps(src + i);
                    v = _mm256_mul_ps(_mm256_sub_ps(v, vmean), vstd);
                    v = _mm256_fmadd_ps(v, vgw, vgb);
                    v = sva(v);
                    _mm256_storeu_ps(dst + i, v);
                }
                for (; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    v = v * gw + gb;
                    dst[i] = silu(v);
                }
            } else {
                const __m256 vgw = _mm256_set1_ps(gw);
                const __m256 vgb = _mm256_set1_ps(gb);
                int i = 0;
                for (; i < kVec; i += 8) {
                    __m256 v = _mm256_loadu_ps(src + i);
                    v = _mm256_mul_ps(_mm256_sub_ps(v, vmean), vstd);
                    v = _mm256_fmadd_ps(v, vgw, vgb);
                    _mm256_storeu_ps(dst + i, v);
                }
                for (; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    dst[i] = v * gw + gb;
                }
            }
        }
    }
}

__attribute__((target("avx2,fma")))
static void asa(float* x, const float* z, size_t n) {
    for (size_t i = 0; i < n; i += 8) {
        __m256 v = _mm256_add_ps(_mm256_loadu_ps(x + i), _mm256_loadu_ps(z + i));
        v = sva(v);
        _mm256_storeu_ps(x + i, v);
    }
}

static void rdb(
    float* x,
    float* y,
    float* z,
    int channels,
    int b,
    int gg,
    const float* dw_w,
    const float* dw_gn_w,
    const float* dw_gn_b,
    const float* pw_w,
    const float* pw_gn_w,
    const float* pw_gn_b) {
    const size_t ch = static_cast<size_t>(channels);
    for (int bi = 0; bi < b; bi++) {
        const size_t b_off_h = static_cast<size_t>(bi) * ch;
        const size_t b_off_dw = b_off_h * 9ULL;
        const size_t b_off_pw = b_off_h * ch;

        d3a(x, channels, dw_w + b_off_dw, y);
        gna(y, channels, gg, dw_gn_w + b_off_h, dw_gn_b + b_off_h, y, true);

        c1a(y, channels, channels, pw_w + b_off_pw, z);
        gna(z, channels, gg, pw_gn_w + b_off_h, pw_gn_b + b_off_h, z, false);

        asa(x, z, ch * CELL_MAX);
    }
}

static void rpl(
    const CM& model,
    const A<float, FEATURE_INPUT_C * CELL_MAX>& board,
    int m,
    A<float, CELL_MAX>& ol) {
    A<float, HIDDEN_C * CELL_MAX> xm;
    A<float, HIDDEN_C * CELL_MAX> ym;
    A<float, HIDDEN_C * CELL_MAX> zm;
    A<float, PLAYER_HIDDEN_C * CELL_MAX> cpj;
    A<float, PLAYER_HIDDEN_C * CELL_MAX> py;
    A<float, PLAYER_HIDDEN_C * CELL_MAX> pyy;
    A<float, PLAYER_HIDDEN_C * CELL_MAX> pyz;
    A<float, PLAYER_BRANCH_N * PLAYER_HIDDEN_C * CELL_MAX> pcat;

    c1a(board.data(), model.ic, model.h, model.msw.data(), ym.data());
    gna(
        ym.data(),
        model.h,
        model.gg,
        model.msgw.data(),
        model.msgb.data(),
        xm.data(),
        true);

    rdb(
        xm.data(),
        ym.data(),
        zm.data(),
        model.h,
        model.fb,
        model.gg,
        model.mfdw.data(),
        model.mfdgw.data(),
        model.mfdgb.data(),
        model.mfpw.data(),
        model.mfpgw.data(),
        model.mfpgb.data());

    c1a(
        board.data(),
        PLAYER_COMMON_INPUT_C,
        model.ph,
        model.pscw.data(),
        cpj.data());

    const size_t ph = static_cast<size_t>(model.ph);
    const size_t ph_plane = ph * CELL_MAX;
    for (int enemy = 0; enemy < PLAYER_BRANCH_N; enemy++) {
        float* dst_cat = pcat.data() + static_cast<size_t>(enemy) * ph_plane;
        if (enemy + 1 >= m) {
            std::memset(dst_cat, 0, sizeof(float) * ph_plane);
            continue;
        }

        const int enemy_ch0 = R4_GLOBAL_C + (enemy + 1) * R4_PLAYER_PER_C;

        c1a(
            board.data() + static_cast<size_t>(enemy_ch0) * CELL_MAX,
            PLAYER_ENEMY_FEAT_INPUT_C,
            model.ph,
            model.psew.data(),
            py.data());

        const float* id_bias = model.peid.data() + static_cast<size_t>(enemy) * ph;
        for (size_t cidx = 0; cidx < ph; cidx++) {
            const float b = id_bias[cidx];
            float* ydst = py.data() + cidx * CELL_MAX;
            const float* csrc = cpj.data() + cidx * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                ydst[i] += csrc[i] + b;
            }
        }
        gna(
            py.data(),
            model.ph,
            model.pgg,
            model.psgw.data(),
            model.psgb.data(),
            py.data(),
            true);

        rdb(
            py.data(),
            pyy.data(),
            pyz.data(),
            model.ph,
            model.fb,
            model.pgg,
            model.pfdw.data(),
            model.pfdgw.data(),
            model.pfdgb.data(),
            model.pfpw.data(),
            model.pfpgw.data(),
            model.pfpgb.data());

        std::memcpy(dst_cat, py.data(), sizeof(float) * ph_plane);
    }

    c1a(xm.data(), model.h, model.h, model.mmw.data(), ym.data());
    c1a(
        pcat.data(),
        PLAYER_BRANCH_N * model.ph,
        model.h,
        model.mpw.data(),
        zm.data());
    for (size_t i = 0; i < ym.size(); i++) {
        ym[i] += zm[i];
    }
    gna(
        ym.data(),
        model.h,
        model.gg,
        model.mgw.data(),
        model.mgb.data(),
        ym.data(),
        true);
    for (size_t i = 0; i < xm.size(); i++) {
        xm[i] += ym[i];
    }

    rdb(
        xm.data(),
        ym.data(),
        zm.data(),
        model.h,
        model.bb,
        model.gg,
        model.mbdw.data(),
        model.mbdgw.data(),
        model.mbdgb.data(),
        model.mbpw.data(),
        model.mbpgw.data(),
        model.mbpgb.data());

    pla(xm.data(), model.h, model.pw.data(), model.pb, ol.data());
}

static int sa0(
    const CM& model,
    const A<float, FEATURE_INPUT_C * CELL_MAX>& board,
    const A<uint8_t, CELL_MAX>& mask,
    int m) {
    A<uint8_t, CELL_MAX> legal{};
    int legal_n = 0;
    for (int idx = 0; idx < CELL_MAX; idx++) {
        if (mask[static_cast<size_t>(idx)]) {
            legal[static_cast<size_t>(legal_n++)] = static_cast<uint8_t>(idx);
        }
    }
    if (legal_n == 0) {
        return cell_index(0, 0);
    }
    A<float, CELL_MAX> lgs;
    rpl(model, board, m, lgs);
    int best = static_cast<int>(legal[0]);
    float best_v = -std::numeric_limits<float>::infinity();
    for (int li = 0; li < legal_n; li++) {
        const int idx = static_cast<int>(legal[static_cast<size_t>(li)]);
        const float v = lgs[static_cast<size_t>(idx)];
        if (v > best_v) {
            best = idx;
            best_v = v;
        }
    }
    return best;
}

static inline void cds(const A<uint8_t, CELL_MAX>& is_source, float* out_plane) {
    constexpr int INF = 1 << 20;
    A<int, CELL_MAX> dist{};
    bool has_source = false;
    for (int i = 0; i < CELL_MAX; i++) {
        if (is_source[static_cast<size_t>(i)]) {
            dist[static_cast<size_t>(i)] = 0;
            has_source = true;
        } else {
            dist[static_cast<size_t>(i)] = INF;
        }
    }
    if (!has_source) {
        for (int i = 0; i < CELL_MAX; i++)
            out_plane[i] = 1.0f;
        return;
    }
    for (int x = 0; x < N; x++) {
        for (int y = 0; y < N; y++) {
            const int idx = cell_index(x, y);
            int d = dist[static_cast<size_t>(idx)];
            if (x > 0)
                d = std::min(d, dist[static_cast<size_t>(cell_index(x - 1, y))] + 1);
            if (y > 0)
                d = std::min(d, dist[static_cast<size_t>(cell_index(x, y - 1))] + 1);
            dist[static_cast<size_t>(idx)] = d;
        }
    }
    for (int x = N - 1; x >= 0; x--) {
        for (int y = N - 1; y >= 0; y--) {
            const int idx = cell_index(x, y);
            int d = dist[static_cast<size_t>(idx)];
            if (x + 1 < N)
                d = std::min(d, dist[static_cast<size_t>(cell_index(x + 1, y))] + 1);
            if (y + 1 < N)
                d = std::min(d, dist[static_cast<size_t>(cell_index(x, y + 1))] + 1);
            dist[static_cast<size_t>(idx)] = d;
        }
    }
    constexpr float INV_MAX_DIST = 1.0f / 18.0f;
    for (int i = 0; i < CELL_MAX; i++) {
        const int d = dist[static_cast<size_t>(i)];
        out_plane[i] = (d >= INF) ? 1.0f : (static_cast<float>(d) * INV_MAX_DIST);
    }
}

static inline void efs(
    const State& st,
    int turn,
    const A<AdfBetaEstimator, M_MAX>* adf_beta,
    const A<int64_t, M_MAX>* psr,
    float* ob,              // [FEATURE_INPUT_C][100]
    uint8_t* am, // [100]
    A<A<int, CELL_MAX>, M_MAX>& moves,
    A<int, M_MAX>& mc,
    A<A<uint8_t, CELL_MAX>, M_MAX>& comp,
    A<A<uint8_t, CELL_MAX>, M_MAX>& reach) {
    constexpr int ps = CELL_MAX;
    std::memset(ob, 0, static_cast<size_t>(FEATURE_INPUT_C * ps) * sizeof(float));

    mc.fill(0);
    for (int p = 0; p < st.m; p++) {
        mc[static_cast<size_t>(p)] = enumerate_legal_moves(
            st,
            p,
            moves[static_cast<size_t>(p)],
            &comp[static_cast<size_t>(p)],
            &reach[static_cast<size_t>(p)]);
    }
    for (int p = st.m; p < M_MAX; p++) {
        mc[static_cast<size_t>(p)] = 0;
        comp[static_cast<size_t>(p)].fill(0);
        reach[static_cast<size_t>(p)].fill(0);
    }
    for (int idx = 0; idx < CELL_MAX; idx++) {
        am[idx] = (st.m > 0 && reach[0][static_cast<size_t>(idx)]) ? 1 : 0;
    }

    A<int64_t, M_MAX> sr{};
    sr.fill(0);
    if (psr != nullptr) {
        for (int p = 0; p < st.m; p++)
            sr[static_cast<size_t>(p)] = (*psr)[static_cast<size_t>(p)];
    } else {
        for (int idx = 0; idx < CELL_MAX; idx++) {
            const int o = static_cast<int>(st.owner[static_cast<size_t>(idx)]);
            if (0 <= o && o < st.m) {
                sr[static_cast<size_t>(o)] += static_cast<int64_t>(st.value[static_cast<size_t>(idx)]) *
                                                         static_cast<int64_t>(st.level[static_cast<size_t>(idx)]);
            }
        }
    }

    A<int, M_MAX> on{};
    for (int p = 0; p < M_MAX; p++)
        on[static_cast<size_t>(p)] = p;
    if (st.m >= 3) {
        A<int, M_MAX> opp_old{};
        int opp_n = 0;
        for (int p = 1; p < st.m; p++)
            opp_old[static_cast<size_t>(opp_n++)] = p;
        std::sort(opp_old.begin(), opp_old.begin() + opp_n, [&](int a, int b) {
            const auto sa = sr[static_cast<size_t>(a)];
            const auto sb = sr[static_cast<size_t>(b)];
            if (sa != sb)
                return sa > sb;
            return a < b;
        });
        for (int i = 0; i < opp_n; i++) {
            const int old_p = opp_old[static_cast<size_t>(i)];
            on[static_cast<size_t>(old_p)] = i + 1;
        }
    }

    A<A<float, CELL_MAX>, M_MAX> next{};
    for (int p = 0; p < M_MAX; p++)
        next[static_cast<size_t>(p)].fill(0.0f);
    for (int p = 0; p < st.m; p++) {
        const int n = mc[static_cast<size_t>(p)];
        if (n <= 0)
            continue;
        if (p == 0 || adf_beta == nullptr) {
            const float prob = 1.0f / static_cast<float>(n);
            for (int i = 0; i < n; i++) {
                const int idx = moves[static_cast<size_t>(p)][static_cast<size_t>(i)];
                next[static_cast<size_t>(p)][static_cast<size_t>(idx)] = prob;
            }
            continue;
        }
        const OpponentParam param = (*adf_beta)[static_cast<size_t>(p)].mean_param();
        A<float, CELL_MAX> tmp_dist{};
        compute_move_dist_ai_like_from_moves(
            st,
            p,
            param,
            moves[static_cast<size_t>(p)].data(),
            n,
            tmp_dist.data());
        for (int idx = 0; idx < CELL_MAX; idx++)
            next[static_cast<size_t>(p)][static_cast<size_t>(idx)] = tmp_dist[static_cast<size_t>(idx)];
    }

    const float v_scale = 1.0f / 1000.0f;
    const float inv_u_fixed = 1.0f / 5.0f;
    for (int idx = 0; idx < ps; idx++) {
        ob[0 * ps + idx] = static_cast<float>(st.value[static_cast<size_t>(idx)]) * v_scale;
        ob[1 * ps + idx] = static_cast<float>(st.level[static_cast<size_t>(idx)]) * inv_u_fixed;
        const int o = static_cast<int>(st.owner[static_cast<size_t>(idx)]);
        if (o == -1) {
            ob[2 * ps + idx] = 1.0f;
        } else if (0 <= o && o < M_MAX) {
            const int np = on[static_cast<size_t>(o)];
            ob[pc(np, 0) * ps + idx] = 1.0f;
        }
    }

    for (int old_p = 0; old_p < M_MAX; old_p++) {
        const int np = on[static_cast<size_t>(old_p)];
        for (int idx = 0; idx < ps; idx++) {
            if (comp[static_cast<size_t>(old_p)][static_cast<size_t>(idx)])
                ob[pc(np, 1) * ps + idx] = 1.0f;
            if (reach[static_cast<size_t>(old_p)][static_cast<size_t>(idx)])
                ob[pc(np, 2) * ps + idx] = 1.0f;
            ob[pc(np, 3) * ps + idx] =
                next[static_cast<size_t>(old_p)][static_cast<size_t>(idx)];
        }
    }

    constexpr float INV_SCORE_SCALE = 1.0f / 50000.0f;
    for (int old_p = 0; old_p < st.m; old_p++) {
        const int np = on[static_cast<size_t>(old_p)];
        const float v = static_cast<float>(sr[static_cast<size_t>(old_p)]) * INV_SCORE_SCALE;
        for (int idx = 0; idx < ps; idx++)
            ob[pc(np, 4) * ps + idx] = v;
    }

    const float tf = (st.t_max > 0) ? (static_cast<float>(turn) / static_cast<float>(st.t_max)) : 0.0f;
    const float in1 = (N > 1) ? (1.0f / static_cast<float>(N - 1)) : 0.0f;
    const float p0x = static_cast<float>(st.ex[0]) * in1;
    const float p0y = static_cast<float>(st.ey[0]) * in1;
    for (int idx = 0; idx < ps; idx++) {
        ob[3 * ps + idx] = tf;
        ob[147 * ps + idx] = p0x;
        ob[148 * ps + idx] = p0y;
    }

    if (2 <= st.m && st.m <= 8) {
        const int ch = 7 + (st.m - 2);
        for (int idx = 0; idx < ps; idx++)
            ob[ch * ps + idx] = 1.0f;
    }
    if (1 <= st.u_max && st.u_max <= 5) {
        const int ch = 14 + (st.u_max - 1);
        for (int idx = 0; idx < ps; idx++)
            ob[ch * ps + idx] = 1.0f;
    }

    A<A<uint8_t, CELL_MAX>, M_MAX> os{};
    A<A<uint8_t, CELL_MAX>, M_MAX> cs{};
    for (int p = 0; p < M_MAX; p++) {
        os[static_cast<size_t>(p)].fill(0);
        cs[static_cast<size_t>(p)].fill(0);
    }
    for (int idx = 0; idx < ps; idx++) {
        const int o = static_cast<int>(st.owner[static_cast<size_t>(idx)]);
        if (0 <= o && o < st.m) {
            const int np = on[static_cast<size_t>(o)];
            os[static_cast<size_t>(np)][static_cast<size_t>(idx)] = 1;
        }
    }
    for (int old_p = 0; old_p < st.m; old_p++) {
        const int np = on[static_cast<size_t>(old_p)];
        for (int idx = 0; idx < ps; idx++) {
            if (comp[static_cast<size_t>(old_p)][static_cast<size_t>(idx)])
                cs[static_cast<size_t>(np)][static_cast<size_t>(idx)] = 1;
        }
    }
    A<float, CELL_MAX> dpn{};
    for (int np = 0; np < M_MAX; np++) {
        cds(os[static_cast<size_t>(np)], dpn.data());
        for (int idx = 0; idx < ps; idx++)
            ob[pc(np, 5) * ps + idx] = dpn[static_cast<size_t>(idx)];
        cds(cs[static_cast<size_t>(np)], dpn.data());
        for (int idx = 0; idx < ps; idx++)
            ob[pc(np, 6) * ps + idx] = dpn[static_cast<size_t>(idx)];
    }

    A<double, M_MAX> ols{};
    A<double, M_MAX> olvs{};
    A<double, M_MAX> cls{};
    A<double, M_MAX> clvs{};
    ols.fill(0.0);
    olvs.fill(0.0);
    cls.fill(0.0);
    clvs.fill(0.0);

    for (int idx = 0; idx < ps; idx++) {
        const int old_o = static_cast<int>(st.owner[static_cast<size_t>(idx)]);
        if (0 <= old_o && old_o < st.m) {
            const int np = on[static_cast<size_t>(old_o)];
            const double lv = static_cast<double>(st.level[static_cast<size_t>(idx)]);
            const double lvv = lv * static_cast<double>(st.value[static_cast<size_t>(idx)]);
            ols[static_cast<size_t>(np)] += lv;
            olvs[static_cast<size_t>(np)] += lvv;
        }
    }
    for (int old_p = 0; old_p < st.m; old_p++) {
        const int np = on[static_cast<size_t>(old_p)];
        double sum_l = 0.0;
        double sum_lv = 0.0;
        for (int idx = 0; idx < ps; idx++) {
            if (!comp[static_cast<size_t>(old_p)][static_cast<size_t>(idx)])
                continue;
            const double lv = static_cast<double>(st.level[static_cast<size_t>(idx)]);
            sum_l += lv;
            sum_lv += lv * static_cast<double>(st.value[static_cast<size_t>(idx)]);
        }
        cls[static_cast<size_t>(np)] = sum_l;
        clvs[static_cast<size_t>(np)] = sum_lv;
    }

    constexpr double INV_LEVEL_SUM_SCALE = 1.0 / (100.0 * 5.0);
    constexpr double INV_LEVEL_VALUE_SUM_SCALE = 1.0 / (100.0 * 5.0 * 1000.0);
    for (int np = 0; np < M_MAX; np++) {
        const float owner_l = static_cast<float>(ols[static_cast<size_t>(np)] * INV_LEVEL_SUM_SCALE);
        const float owner_lv =
            static_cast<float>(olvs[static_cast<size_t>(np)] * INV_LEVEL_VALUE_SUM_SCALE);
        const float comp_l = static_cast<float>(cls[static_cast<size_t>(np)] * INV_LEVEL_SUM_SCALE);
        const float comp_lv =
            static_cast<float>(clvs[static_cast<size_t>(np)] * INV_LEVEL_VALUE_SUM_SCALE);
        for (int idx = 0; idx < ps; idx++) {
            ob[pc(np, 7) * ps + idx] = owner_l;
            ob[pc(np, 8) * ps + idx] = owner_lv;
            ob[pc(np, 9) * ps + idx] = comp_l;
            ob[pc(np, 10) * ps + idx] = comp_lv;
        }
    }

    if (adf_beta != nullptr) {
        for (int old_p = 0; old_p < st.m; old_p++) {
            const int np = on[static_cast<size_t>(old_p)];
            const OpponentParam est = (*adf_beta)[static_cast<size_t>(old_p)].mean_param();
            double sumw = est.wa + est.wb + est.wc + est.wd;
            if (!(sumw > 0.0))
                sumw = 1.0;
            const float wa = static_cast<float>(est.wa / sumw);
            const float wb = static_cast<float>(est.wb / sumw);
            const float wc = static_cast<float>(est.wc / sumw);
            const float wd = static_cast<float>(est.wd / sumw);
            const float eps = static_cast<float>(est.eps);
            for (int idx = 0; idx < ps; idx++) {
                ob[pc(np, 11) * ps + idx] = wa;
                ob[pc(np, 12) * ps + idx] = wb;
                ob[pc(np, 13) * ps + idx] = wc;
                ob[pc(np, 14) * ps + idx] = wd;
                ob[pc(np, 15) * ps + idx] = eps;
            }
        }
    }

    constexpr float CX = 4.5f;
    constexpr float CY = 4.5f;
    constexpr float INV_MAX_CENTER = 1.0f / 9.0f;
    for (int x = 0; x < N; x++) {
        for (int y = 0; y < N; y++) {
            const int idx = cell_index(x, y);
            const float dx = std::abs(static_cast<float>(x) - CX);
            const float dy = std::abs(static_cast<float>(y) - CY);
            ob[4 * ps + idx] = (dx + dy) * INV_MAX_CENTER;
            ob[5 * ps + idx] = static_cast<float>(x) * in1;
            ob[6 * ps + idx] = static_cast<float>(y) * in1;
        }
    }
}

static inline void rsr(const State& st, A<int64_t, M_MAX>& score) {
    score.fill(0);
    for (int idx = 0; idx < CELL_MAX; idx++) {
        const int o = static_cast<int>(st.owner[idx]);
        if (0 <= o && o < st.m) {
            score[static_cast<size_t>(o)] +=
                static_cast<int64_t>(st.value[idx]) * static_cast<int64_t>(st.level[idx]);
        }
    }
}

}  // namespace ahc061::exp002

int main() {
    using namespace std;
    using namespace ahc061::exp002;

    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 0, m = 0, t_max = 0, u_max = 0;
    if (!(cin >> n >> m >> t_max >> u_max))
        return 0;
    if (n != N)
        return 0;
    if (m < 2 || m > M_MAX)
        return 0;

    State st{};
    st.m = m;
    st.t_max = t_max;
    st.u_max = u_max;

    for (int x = 0; x < N; x++) {
        for (int y = 0; y < N; y++) {
            int v = 0;
            cin >> v;
            st.value[cell_index(x, y)] = v;
        }
    }

    for (int p = 0; p < m; p++) {
        int sx = 0, sy = 0;
        cin >> sx >> sy;
        st.ex[p] = static_cast<uint8_t>(sx);
        st.ey[p] = static_cast<uint8_t>(sy);
    }
    st.owner.fill(-1);
    st.level.fill(0);
    for (int p = 0; p < m; p++) {
        const int idx = cell_index(static_cast<int>(st.ex[p]), static_cast<int>(st.ey[p]));
        st.owner[idx] = static_cast<int8_t>(p);
        st.level[idx] = 1;
    }

    A<AdfBetaEstimator, M_MAX> adf_beta{};
    A<int64_t, M_MAX> sr{};
    for (int p = 0; p < m; p++) {
        adf_beta[static_cast<size_t>(p)].reset();
    }
    rsr(st, sr);

    const CM model = lcm();

    for (int turn = 0; turn < t_max; turn++) {
        const State st_start = st;

        A<float, FEATURE_INPUT_C * CELL_MAX> board{};
        A<uint8_t, CELL_MAX> mask{};
        A<A<int, CELL_MAX>, M_MAX> moves{};
        A<int, M_MAX> mc{};
        A<A<uint8_t, CELL_MAX>, M_MAX> comp{};
        A<A<uint8_t, CELL_MAX>, M_MAX> reach{};
        efs(
            st,
            turn,
            &adf_beta,
            &sr,
            board.data(),
            mask.data(),
            moves,
            mc,
            comp,
            reach);

        const int action_cell = sa0(model, board, mask, st.m);
        const int ax = action_cell / N;
        const int ay = action_cell % N;
        cout << ax << ' ' << ay << '\n' << flush;

        A<int, M_MAX> tx{};
        A<int, M_MAX> ty{};
        for (int p = 0; p < m; p++) {
            cin >> tx[p] >> ty[p];
        }

        for (int p = 1; p < m; p++) {
            const int c = cell_index(tx[p], ty[p]);
            const MoveSummary sum = summarize_ai_observation_from_moves(
                st_start,
                p,
                c,
                moves[static_cast<size_t>(p)].data(),
                mc[static_cast<size_t>(p)]);
            adf_beta[static_cast<size_t>(p)].update(sum);
        }

        for (int p = 0; p < m; p++) {
            int ex = 0, ey = 0;
            cin >> ex >> ey;
            st.ex[p] = static_cast<uint8_t>(ex);
            st.ey[p] = static_cast<uint8_t>(ey);
        }

        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                int o = 0;
                cin >> o;
                st.owner[cell_index(x, y)] = static_cast<int8_t>(o);
            }
        }
        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                int l = 0;
                cin >> l;
                st.level[cell_index(x, y)] = static_cast<uint8_t>(l);
            }
        }
        rsr(st, sr);
    }

    return 0;
}
