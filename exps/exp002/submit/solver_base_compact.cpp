// exp002 submit (compact int8/fp16, no torch runtime)
// NOTE: This file is NOT a single-file submission by itself.
// Use make_submit_compact.py to bundle local headers + embed the model.

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <limits>
#include <string_view>
#include <vector>

#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
#include <immintrin.h>
#define AHC061_HAS_X86_AVX2_TARGET 1
#else
#define AHC061_HAS_X86_AVX2_TARGET 0
#endif

#include "ahc061/core/generator.hpp"
#include "ahc061/core/pf.hpp"
#include "ahc061/core/rules.hpp"
#include "ahc061/core/state.hpp"

// GENERATED by make_submit_compact.py (feature-specific).
#include "feature_config.inc"
#include "model_compact_encoded.inc"

namespace ahc061::exp002 {

static constexpr int HIDDEN_C = static_cast<int>(kModelMeta_hidden);
static constexpr int BLOCKS_N = static_cast<int>(kModelMeta_blocks);
static constexpr int IN_CHANNELS = static_cast<int>(kModelMeta_in_channels);
static constexpr int PAYLOAD_CODEC = static_cast<int>(kModelMeta_payload_codec);
static constexpr int PAYLOAD_CODEC_BASE91 = 91;
static constexpr int PAYLOAD_CODEC_BASE122 = 122;
static constexpr int PAYLOAD_CODEC_HUFF122 = 1122;
static_assert(HIDDEN_C > 0, "hidden must be positive");
static_assert(BLOCKS_N > 0, "blocks must be positive");
static_assert(IN_CHANNELS > 0, "in_channels must be positive");
static_assert(
    PAYLOAD_CODEC == PAYLOAD_CODEC_BASE91 || PAYLOAD_CODEC == PAYLOAD_CODEC_BASE122 ||
        PAYLOAD_CODEC == PAYLOAD_CODEC_HUFF122,
    "payload codec must be 91/122/1122");

static std::string_view encoded_q_view() {
    return std::string_view(reinterpret_cast<const char*>(kModelQEncoded), sizeof(kModelQEncoded) - 1ULL);
}

static std::string_view encoded_h_view() {
    return std::string_view(reinterpret_cast<const char*>(kModelHEncoded), sizeof(kModelHEncoded) - 1ULL);
}

static std::vector<std::uint8_t> base91_decode(std::string_view s) {
    static constexpr std::array<std::int16_t, 256> kDec = [] {
        std::array<std::int16_t, 256> t{};
        t.fill(-1);
        int idx = 0;
        for (int c = 1; c <= 31; c++) {
            if (c == 10 || c == 13)
                continue;
            t[static_cast<std::uint8_t>(c)] = static_cast<std::int16_t>(idx++);
        }
        for (int c = 32; c <= 127; c++) {
            t[static_cast<std::uint8_t>(c)] = static_cast<std::int16_t>(idx++);
        }
        return t;
    }();

    std::vector<std::uint8_t> out;
    out.reserve(s.size() * 13 / 16 + 8);

    int v = -1;
    std::uint32_t b = 0;
    int n = 0;
    for (unsigned char uc : s) {
        if (uc == '\n')
            continue;
        const int d = static_cast<int>(kDec[uc]);
        if (d < 0)
            continue;
        if (v < 0) {
            v = d;
            continue;
        }
        const int val = v + d * 125;
        b |= static_cast<std::uint32_t>(val) << n;
        n += ((val & 8191) < 7433) ? 14 : 13;
        while (n > 7) {
            out.push_back(static_cast<std::uint8_t>(b & 0xFFU));
            b >>= 8;
            n -= 8;
        }
        v = -1;
    }
    if (v >= 0) {
        out.push_back(static_cast<std::uint8_t>((b | (static_cast<std::uint32_t>(v) << n)) & 0xFFU));
    }
    return out;
}

static std::vector<std::uint8_t> base122_decode(std::string_view s) {
    static constexpr std::array<std::uint8_t, 7> kIllegals = {0, 10, 13, 34, 38, 63, 92};
    static constexpr std::uint8_t kShortened = 7;
    std::vector<std::uint8_t> out;
    out.reserve(s.size());

    std::uint8_t cur_byte = 0;
    int bit_of_byte = 0;
    const auto push7 = [&](std::uint8_t seven) {
        const std::uint16_t byte = static_cast<std::uint16_t>(seven & 0x7FU) << 1;
        cur_byte |= static_cast<std::uint8_t>(byte >> bit_of_byte);
        bit_of_byte += 7;
        if (bit_of_byte >= 8) {
            out.push_back(cur_byte);
            bit_of_byte -= 8;
            cur_byte = static_cast<std::uint8_t>((byte << (7 - bit_of_byte)) & 0xFFU);
        }
    };

    for (std::size_t i = 0; i < s.size(); i++) {
        const std::uint8_t b0 = static_cast<std::uint8_t>(s[i]);
        std::uint16_t cp = 0;
        if ((b0 & 0x80U) == 0U) {
            cp = b0;
        } else {
            if ((b0 & 0xE0U) != 0xC0U || (i + 1) >= s.size())
                continue;
            const std::uint8_t b1 = static_cast<std::uint8_t>(s[++i]);
            if ((b1 & 0xC0U) != 0x80U)
                continue;
            cp = static_cast<std::uint16_t>(((b0 & 0x1FU) << 6) | (b1 & 0x3FU));
        }

        if (cp > 127U) {
            const std::uint8_t illegal_index = static_cast<std::uint8_t>((cp >> 8) & 0x07U);
            if (illegal_index != kShortened) {
                if (illegal_index >= kIllegals.size())
                    continue;
                push7(kIllegals[illegal_index]);
            }
            push7(static_cast<std::uint8_t>(cp & 0x7FU));
        } else {
            push7(static_cast<std::uint8_t>(cp));
        }
    }
    return out;
}

static std::vector<std::uint8_t> huff122_decompress(const std::vector<std::uint8_t>& blob, std::size_t expected_size) {
    std::vector<std::uint8_t> out;
    out.reserve(expected_size);
    if (expected_size == 0)
        return out;
    if (blob.size() < 256ULL)
        return {};

    struct SymLen {
        std::uint16_t sym;
        std::uint8_t len;
    };
    std::vector<SymLen> syms;
    syms.reserve(256);
    for (int s = 0; s < 256; s++) {
        const std::uint8_t ln = blob[static_cast<std::size_t>(s)];
        if (ln > 0) {
            syms.push_back(SymLen{static_cast<std::uint16_t>(s), ln});
        }
    }
    if (syms.empty())
        return {};

    std::sort(syms.begin(), syms.end(), [](const SymLen& a, const SymLen& b) {
        if (a.len != b.len)
            return a.len < b.len;
        return a.sym < b.sym;
    });

    std::vector<int> left(1, -1), right(1, -1), value(1, -1);
    std::uint64_t code = 0;
    int prev_len = 0;
    for (const SymLen sl : syms) {
        const int ln = static_cast<int>(sl.len);
        if (ln < prev_len || ln > 63)
            return {};
        code <<= static_cast<std::uint64_t>(ln - prev_len);
        int node = 0;
        for (int k = ln - 1; k >= 0; k--) {
            const int bit = static_cast<int>((code >> static_cast<unsigned>(k)) & 1ULL);
            int nxt = bit ? right[node] : left[node];
            if (nxt < 0) {
                nxt = static_cast<int>(value.size());
                left.push_back(-1);
                right.push_back(-1);
                value.push_back(-1);
                if (bit) {
                    right[node] = nxt;
                } else {
                    left[node] = nxt;
                }
            }
            node = nxt;
        }
        value[node] = static_cast<int>(sl.sym);
        code += 1ULL;
        prev_len = ln;
    }

    int node = 0;
    for (std::size_t i = 256ULL; i < blob.size(); i++) {
        const std::uint8_t by = blob[i];
        for (int k = 7; k >= 0; k--) {
            const int bit = static_cast<int>((by >> static_cast<unsigned>(k)) & 1U);
            node = bit ? right[node] : left[node];
            if (node < 0)
                return {};
            const int sym = value[node];
            if (sym >= 0) {
                out.push_back(static_cast<std::uint8_t>(sym));
                if (out.size() == expected_size)
                    return out;
                node = 0;
            }
        }
    }
    return {};
}

static std::vector<std::uint8_t> decode_payload(std::string_view s, std::size_t expected_size) {
    if constexpr (PAYLOAD_CODEC == PAYLOAD_CODEC_HUFF122) {
        const std::vector<std::uint8_t> packed = base122_decode(s);
        return huff122_decompress(packed, expected_size);
    } else if constexpr (PAYLOAD_CODEC == PAYLOAD_CODEC_BASE122) {
        return base122_decode(s);
    } else {
        return base91_decode(s);
    }
}

static float half_to_float(std::uint16_t h) {
    const std::uint32_t sign = static_cast<std::uint32_t>(h & 0x8000U) << 16;
    std::uint32_t exp = static_cast<std::uint32_t>((h >> 10) & 0x1FU);
    std::uint32_t frac = static_cast<std::uint32_t>(h & 0x03FFU);
    std::uint32_t f = 0;

    if (exp == 0) {
        if (frac == 0) {
            f = sign;
        } else {
            exp = 1;
            while ((frac & 0x0400U) == 0U) {
                frac <<= 1;
                exp--;
            }
            frac &= 0x03FFU;
            f = sign | ((exp + 112U) << 23) | (frac << 13);
        }
    } else if (exp == 31) {
        f = sign | 0x7F800000U | (frac << 13);
    } else {
        f = sign | ((exp + 112U) << 23) | (frac << 13);
    }

    float out = 0.0F;
    std::memcpy(&out, &f, sizeof(float));
    return out;
}

static int pick_gn_groups(int channels) {
    for (int g : {8, 4, 2, 1}) {
        if (channels % g == 0)
            return g;
    }
    return 1;
}

struct CompactModel {
    int in_channels = 0;
    int hidden = 0;
    int blocks = 0;
    int gn_groups = 1;

    std::vector<float> stem_w;    // [C][H] (transposed)
    std::vector<float> stem_gn_w; // [H]
    std::vector<float> stem_gn_b; // [H]

    std::vector<float> dw_w;      // [B][H][9]
    std::vector<float> dw_gn_w;   // [B][H]
    std::vector<float> dw_gn_b;   // [B][H]

    std::vector<float> pw_w;      // [B][H][H] (block-wise transposed, [ic][oc])
    std::vector<float> pw_gn_w;   // [B][H]
    std::vector<float> pw_gn_b;   // [B][H]

    std::vector<float> policy_w;  // [H]
    float policy_b = 0.0F;
};

static CompactModel load_compact_model() {
    const std::vector<std::uint8_t> q_bytes = decode_payload(encoded_q_view(), kModelMeta_q_bytes);
    const std::vector<std::uint8_t> h_bytes = decode_payload(encoded_h_view(), kModelMeta_h_bytes);

    if (q_bytes.size() != kModelMeta_q_bytes) {
        std::cerr << "[ERROR] q blob size mismatch decoded=" << q_bytes.size() << " meta=" << kModelMeta_q_bytes << '\n';
        std::exit(1);
    }
    if (h_bytes.size() != kModelMeta_h_bytes) {
        std::cerr << "[ERROR] h blob size mismatch decoded=" << h_bytes.size() << " meta=" << kModelMeta_h_bytes << '\n';
        std::exit(1);
    }
    if (q_bytes.size() != kModelMeta_q_count) {
        std::cerr << "[ERROR] q count mismatch decoded=" << q_bytes.size() << " expected=" << kModelMeta_q_count << '\n';
        std::exit(1);
    }
    if (h_bytes.size() != kModelMeta_h_count * 2ULL) {
        std::cerr << "[ERROR] h count mismatch decoded=" << h_bytes.size() << " expected=" << (kModelMeta_h_count * 2ULL) << '\n';
        std::exit(1);
    }

    std::vector<float> h_vals(kModelMeta_h_count);
    for (std::size_t i = 0; i < kModelMeta_h_count; i++) {
        const std::uint16_t bits = static_cast<std::uint16_t>(h_bytes[2 * i]) |
                                   (static_cast<std::uint16_t>(h_bytes[2 * i + 1]) << 8);
        h_vals[i] = half_to_float(bits);
    }

    CompactModel model{};
    model.in_channels = IN_CHANNELS;
    model.hidden = HIDDEN_C;
    model.blocks = BLOCKS_N;
    model.gn_groups = pick_gn_groups(model.hidden);

    const std::size_t h = static_cast<std::size_t>(model.hidden);
    const std::size_t b = static_cast<std::size_t>(model.blocks);
    const std::size_t c = static_cast<std::size_t>(model.in_channels);

    model.stem_w.resize(h * c);
    model.stem_gn_w.resize(h);
    model.stem_gn_b.resize(h);
    model.dw_w.resize(b * h * 9ULL);
    model.dw_gn_w.resize(b * h);
    model.dw_gn_b.resize(b * h);
    model.pw_w.resize(b * h * h);
    model.pw_gn_w.resize(b * h);
    model.pw_gn_b.resize(b * h);
    model.policy_w.resize(h);

    const auto* q = reinterpret_cast<const std::int8_t*>(q_bytes.data());
    std::size_t q_off = 0;
    std::size_t h_off = 0;

    for (std::size_t oc = 0; oc < h; oc++) {
        for (std::size_t ic = 0; ic < c; ic++) {
            model.stem_w[ic * h + oc] = h_vals[h_off++];
        }
    }
    for (std::size_t oc = 0; oc < h; oc++) model.stem_gn_w[oc] = h_vals[h_off++];
    for (std::size_t oc = 0; oc < h; oc++) model.stem_gn_b[oc] = h_vals[h_off++];

    std::vector<float> pw_scale(h);
    for (std::size_t bi = 0; bi < b; bi++) {
        const std::size_t bo = bi * h;
        for (std::size_t ci = 0; ci < h; ci++) {
            const std::size_t dst = (bo + ci) * 9ULL;
            for (std::size_t k = 0; k < 9; k++) {
                model.dw_w[dst + k] = h_vals[h_off++];
            }
        }
        for (std::size_t ci = 0; ci < h; ci++) model.dw_gn_w[bo + ci] = h_vals[h_off++];
        for (std::size_t ci = 0; ci < h; ci++) model.dw_gn_b[bo + ci] = h_vals[h_off++];
        for (std::size_t ci = 0; ci < h; ci++) pw_scale[ci] = h_vals[h_off++];
        for (std::size_t ci = 0; ci < h; ci++) model.pw_gn_w[bo + ci] = h_vals[h_off++];
        for (std::size_t ci = 0; ci < h; ci++) model.pw_gn_b[bo + ci] = h_vals[h_off++];
        for (std::size_t oc = 0; oc < h; oc++) {
            const float s = pw_scale[oc];
            for (std::size_t ic = 0; ic < h; ic++) {
                model.pw_w[bo * h + ic * h + oc] = static_cast<float>(q[q_off++]) * s;
            }
        }
    }

    for (std::size_t cidx = 0; cidx < h; cidx++) {
        model.policy_w[cidx] = h_vals[h_off++];
    }
    model.policy_b = h_vals[h_off++];

    if (q_off != kModelMeta_q_count) {
        std::cerr << "[ERROR] q offset mismatch parsed=" << q_off << " expected=" << kModelMeta_q_count << '\n';
        std::exit(1);
    }
    if (h_off != kModelMeta_h_count) {
        std::cerr << "[ERROR] h offset mismatch parsed=" << h_off << " expected=" << kModelMeta_h_count << '\n';
        std::exit(1);
    }
    return model;
}

static inline float fast_sigmoid(float x) {
    const float ax = std::fabs(x);
    return 0.5F * (x / (1.0F + ax) + 1.0F);
}

#ifndef AHC061_EXP002_FAST_SILU
#define AHC061_EXP002_FAST_SILU 2
#endif

#if AHC061_EXP002_FAST_SILU == 2
#ifndef AHC061_EXP002_SILU_LUT_SIZE
#define AHC061_EXP002_SILU_LUT_SIZE 16385
#endif
#ifndef AHC061_EXP002_SILU_LUT_RANGE
#define AHC061_EXP002_SILU_LUT_RANGE 16.0F
#endif
static constexpr int kSiluLutSize = AHC061_EXP002_SILU_LUT_SIZE;
static constexpr float kSiluLutRange = AHC061_EXP002_SILU_LUT_RANGE;
static constexpr float kSiluLutMin = -kSiluLutRange;
static constexpr float kSiluLutMax = kSiluLutRange;
static const std::array<float, kSiluLutSize>& silu_lut_table() {
    static const std::array<float, kSiluLutSize> lut = [] {
        std::array<float, kSiluLutSize> t{};
        for (int i = 0; i < kSiluLutSize; i++) {
            const float x0 = kSiluLutMin +
                             (kSiluLutMax - kSiluLutMin) * static_cast<float>(i) / static_cast<float>(kSiluLutSize - 1);
            t[static_cast<std::size_t>(i)] = 1.0F / (1.0F + std::exp(-x0));
        }
        return t;
    }();
    return lut;
}
static inline float silu_lut_scalar(float x) {
    const auto& lut = silu_lut_table();
    if (x <= kSiluLutMin)
        return x * lut[0];
    if (x >= kSiluLutMax)
        return x * lut[kSiluLutSize - 1];
    const float pos = (x - kSiluLutMin) * static_cast<float>(kSiluLutSize - 1) / (kSiluLutMax - kSiluLutMin);
    const int idx = static_cast<int>(pos);
    const float frac = pos - static_cast<float>(idx);
    const float s0 = lut[static_cast<std::size_t>(idx)];
    const float s1 = lut[static_cast<std::size_t>(idx + 1)];
    return x * (s0 + (s1 - s0) * frac);
}
#endif

static inline float silu(float x) {
#if AHC061_EXP002_FAST_SILU == 1
    return x * fast_sigmoid(x);
#elif AHC061_EXP002_FAST_SILU == 2
    return silu_lut_scalar(x);
#else
    return x / (1.0F + std::exp(-x));
#endif
}

#if AHC061_HAS_X86_AVX2_TARGET
static inline bool can_use_avx2() {
    static int cached = -1;
    if (cached < 0) {
#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
        cached = (__builtin_cpu_supports("avx2") && __builtin_cpu_supports("fma")) ? 1 : 0;
#else
        cached = 0;
#endif
    }
    return cached != 0;
}

__attribute__((target("avx2,fma")))
static void conv1x1_rank1_avx2(const float* in, int in_channels, int out_channels, const float* w_t, float* out) {
    constexpr int kVec = (CELL_MAX / 8) * 8;
    int oc = 0;
    for (; oc + 8 <= out_channels; oc += 8) {
        float* d0 = out + static_cast<std::size_t>(oc + 0) * CELL_MAX;
        float* d1 = out + static_cast<std::size_t>(oc + 1) * CELL_MAX;
        float* d2 = out + static_cast<std::size_t>(oc + 2) * CELL_MAX;
        float* d3 = out + static_cast<std::size_t>(oc + 3) * CELL_MAX;
        float* d4 = out + static_cast<std::size_t>(oc + 4) * CELL_MAX;
        float* d5 = out + static_cast<std::size_t>(oc + 5) * CELL_MAX;
        float* d6 = out + static_cast<std::size_t>(oc + 6) * CELL_MAX;
        float* d7 = out + static_cast<std::size_t>(oc + 7) * CELL_MAX;

        int i = 0;
        for (; i < kVec; i += 8) {
            __m256 acc0 = _mm256_setzero_ps();
            __m256 acc1 = _mm256_setzero_ps();
            __m256 acc2 = _mm256_setzero_ps();
            __m256 acc3 = _mm256_setzero_ps();
            __m256 acc4 = _mm256_setzero_ps();
            __m256 acc5 = _mm256_setzero_ps();
            __m256 acc6 = _mm256_setzero_ps();
            __m256 acc7 = _mm256_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                const __m256 s = _mm256_loadu_ps(src);
                acc0 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[0]), acc0);
                acc1 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[1]), acc1);
                acc2 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[2]), acc2);
                acc3 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[3]), acc3);
                acc4 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[4]), acc4);
                acc5 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[5]), acc5);
                acc6 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[6]), acc6);
                acc7 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[7]), acc7);
            }
            _mm256_storeu_ps(d0 + i, acc0);
            _mm256_storeu_ps(d1 + i, acc1);
            _mm256_storeu_ps(d2 + i, acc2);
            _mm256_storeu_ps(d3 + i, acc3);
            _mm256_storeu_ps(d4 + i, acc4);
            _mm256_storeu_ps(d5 + i, acc5);
            _mm256_storeu_ps(d6 + i, acc6);
            _mm256_storeu_ps(d7 + i, acc7);
        }
        if (i + 4 <= CELL_MAX) {
            __m128 acc0 = _mm_setzero_ps();
            __m128 acc1 = _mm_setzero_ps();
            __m128 acc2 = _mm_setzero_ps();
            __m128 acc3 = _mm_setzero_ps();
            __m128 acc4 = _mm_setzero_ps();
            __m128 acc5 = _mm_setzero_ps();
            __m128 acc6 = _mm_setzero_ps();
            __m128 acc7 = _mm_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                const __m128 s = _mm_loadu_ps(src);
                acc0 = _mm_fmadd_ps(s, _mm_set1_ps(wr[0]), acc0);
                acc1 = _mm_fmadd_ps(s, _mm_set1_ps(wr[1]), acc1);
                acc2 = _mm_fmadd_ps(s, _mm_set1_ps(wr[2]), acc2);
                acc3 = _mm_fmadd_ps(s, _mm_set1_ps(wr[3]), acc3);
                acc4 = _mm_fmadd_ps(s, _mm_set1_ps(wr[4]), acc4);
                acc5 = _mm_fmadd_ps(s, _mm_set1_ps(wr[5]), acc5);
                acc6 = _mm_fmadd_ps(s, _mm_set1_ps(wr[6]), acc6);
                acc7 = _mm_fmadd_ps(s, _mm_set1_ps(wr[7]), acc7);
            }
            _mm_storeu_ps(d0 + i, acc0);
            _mm_storeu_ps(d1 + i, acc1);
            _mm_storeu_ps(d2 + i, acc2);
            _mm_storeu_ps(d3 + i, acc3);
            _mm_storeu_ps(d4 + i, acc4);
            _mm_storeu_ps(d5 + i, acc5);
            _mm_storeu_ps(d6 + i, acc6);
            _mm_storeu_ps(d7 + i, acc7);
            i += 4;
        }
        for (; i < CELL_MAX; i++) {
            float s0 = 0.0F;
            float s1 = 0.0F;
            float s2 = 0.0F;
            float s3 = 0.0F;
            float s4 = 0.0F;
            float s5 = 0.0F;
            float s6 = 0.0F;
            float s7 = 0.0F;
            for (int ic = 0; ic < in_channels; ic++) {
                const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                s0 += v * wr[0];
                s1 += v * wr[1];
                s2 += v * wr[2];
                s3 += v * wr[3];
                s4 += v * wr[4];
                s5 += v * wr[5];
                s6 += v * wr[6];
                s7 += v * wr[7];
            }
            d0[i] = s0;
            d1[i] = s1;
            d2[i] = s2;
            d3[i] = s3;
            d4[i] = s4;
            d5[i] = s5;
            d6[i] = s6;
            d7[i] = s7;
        }
    }

    for (; oc + 4 <= out_channels; oc += 4) {
        float* d0 = out + static_cast<std::size_t>(oc + 0) * CELL_MAX;
        float* d1 = out + static_cast<std::size_t>(oc + 1) * CELL_MAX;
        float* d2 = out + static_cast<std::size_t>(oc + 2) * CELL_MAX;
        float* d3 = out + static_cast<std::size_t>(oc + 3) * CELL_MAX;

        int i = 0;
        for (; i < kVec; i += 8) {
            __m256 acc0 = _mm256_setzero_ps();
            __m256 acc1 = _mm256_setzero_ps();
            __m256 acc2 = _mm256_setzero_ps();
            __m256 acc3 = _mm256_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                const __m256 s = _mm256_loadu_ps(src);
                acc0 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[0]), acc0);
                acc1 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[1]), acc1);
                acc2 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[2]), acc2);
                acc3 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[3]), acc3);
            }
            _mm256_storeu_ps(d0 + i, acc0);
            _mm256_storeu_ps(d1 + i, acc1);
            _mm256_storeu_ps(d2 + i, acc2);
            _mm256_storeu_ps(d3 + i, acc3);
        }
        if (i + 4 <= CELL_MAX) {
            __m128 acc0 = _mm_setzero_ps();
            __m128 acc1 = _mm_setzero_ps();
            __m128 acc2 = _mm_setzero_ps();
            __m128 acc3 = _mm_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                const __m128 s = _mm_loadu_ps(src);
                acc0 = _mm_fmadd_ps(s, _mm_set1_ps(wr[0]), acc0);
                acc1 = _mm_fmadd_ps(s, _mm_set1_ps(wr[1]), acc1);
                acc2 = _mm_fmadd_ps(s, _mm_set1_ps(wr[2]), acc2);
                acc3 = _mm_fmadd_ps(s, _mm_set1_ps(wr[3]), acc3);
            }
            _mm_storeu_ps(d0 + i, acc0);
            _mm_storeu_ps(d1 + i, acc1);
            _mm_storeu_ps(d2 + i, acc2);
            _mm_storeu_ps(d3 + i, acc3);
            i += 4;
        }
        for (; i < CELL_MAX; i++) {
            float s0 = 0.0F;
            float s1 = 0.0F;
            float s2 = 0.0F;
            float s3 = 0.0F;
            for (int ic = 0; ic < in_channels; ic++) {
                const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                s0 += v * wr[0];
                s1 += v * wr[1];
                s2 += v * wr[2];
                s3 += v * wr[3];
            }
            d0[i] = s0;
            d1[i] = s1;
            d2[i] = s2;
            d3[i] = s3;
        }
    }

    for (; oc < out_channels; oc++) {
        float* d0 = out + static_cast<std::size_t>(oc) * CELL_MAX;
        int i = 0;
        for (; i < kVec; i += 8) {
            __m256 acc = _mm256_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float w0 = w_t[static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + static_cast<std::size_t>(oc)];
                acc = _mm256_fmadd_ps(_mm256_loadu_ps(src), _mm256_set1_ps(w0), acc);
            }
            _mm256_storeu_ps(d0 + i, acc);
        }
        if (i + 4 <= CELL_MAX) {
            __m128 acc = _mm_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float w0 = w_t[static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) +
                                     static_cast<std::size_t>(oc)];
                acc = _mm_fmadd_ps(_mm_loadu_ps(src), _mm_set1_ps(w0), acc);
            }
            _mm_storeu_ps(d0 + i, acc);
            i += 4;
        }
        for (; i < CELL_MAX; i++) {
            float s0 = 0.0F;
            for (int ic = 0; ic < in_channels; ic++) {
                const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                const float w0 = w_t[static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + static_cast<std::size_t>(oc)];
                s0 += v * w0;
            }
            d0[i] = s0;
        }
    }
}
#endif

// 1x1 conv using rank-1 accumulation:
// out[oc, idx] = sum_ic in[ic, idx] * w_t[ic, oc]
static void conv1x1_rank1(const float* in, int in_channels, int out_channels, const float* w_t, float* out) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        conv1x1_rank1_avx2(in, in_channels, out_channels, w_t, out);
        return;
    }
#endif
    for (int oc = 0; oc < out_channels; oc++) {
        float* dst = out + static_cast<std::size_t>(oc) * CELL_MAX;
        for (int i = 0; i < CELL_MAX; i++) {
            float s = 0.0F;
            for (int ic = 0; ic < in_channels; ic++) {
                const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                const float w0 = w_t[static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + static_cast<std::size_t>(oc)];
                s += v * w0;
            }
            dst[i] = s;
        }
    }
}

#if AHC061_HAS_X86_AVX2_TARGET
__attribute__((target("avx2,fma")))
static void policy_linear_avx2(const float* x, int channels, const float* w, float bias, float* out_logits) {
    constexpr int kVec = (CELL_MAX / 8) * 8;
    int i = 0;
    const __m256 vbias = _mm256_set1_ps(bias);
    for (; i < kVec; i += 8) {
        _mm256_storeu_ps(out_logits + i, vbias);
    }
    for (; i < CELL_MAX; i++) {
        out_logits[i] = bias;
    }

    for (int c = 0; c < channels; c++) {
        const float wc = w[static_cast<std::size_t>(c)];
        const __m256 vw = _mm256_set1_ps(wc);
        const float* src = x + static_cast<std::size_t>(c) * CELL_MAX;
        int j = 0;
        for (; j < kVec; j += 8) {
            __m256 o = _mm256_loadu_ps(out_logits + j);
            const __m256 s = _mm256_loadu_ps(src + j);
            o = _mm256_fmadd_ps(s, vw, o);
            _mm256_storeu_ps(out_logits + j, o);
        }
        for (; j < CELL_MAX; j++) {
            out_logits[j] += src[j] * wc;
        }
    }
}
#endif

static void policy_linear(const float* x, int channels, const float* w, float bias, float* out_logits) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        policy_linear_avx2(x, channels, w, bias, out_logits);
        return;
    }
#endif
    for (int i = 0; i < CELL_MAX; i++) {
        out_logits[i] = bias;
    }
    for (int c = 0; c < channels; c++) {
        const float wc = w[static_cast<std::size_t>(c)];
        const float* src = x + static_cast<std::size_t>(c) * CELL_MAX;
        for (int i = 0; i < CELL_MAX; i++) {
            out_logits[i] += src[i] * wc;
        }
    }
}

static inline float dwconv3x3_cell(const float* src, const float* wc, int x, int y) {
    float s = 0.0F;
    int k = 0;
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            const int xx = x + dx;
            const int yy = y + dy;
            if (0 <= xx && xx < N && 0 <= yy && yy < N) {
                s += src[cell_index(xx, yy)] * wc[k];
            }
            k++;
        }
    }
    return s;
}

#if AHC061_HAS_X86_AVX2_TARGET
__attribute__((target("avx2,fma")))
static inline float hsum256_ps(__m256 v) {
    alignas(32) float tmp[8];
    _mm256_store_ps(tmp, v);
    return tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7];
}

__attribute__((target("avx2,fma")))
static void dwconv3x3_avx2(const float* in, int channels, const float* w, float* out) {
    for (int c = 0; c < channels; c++) {
        const float* wc = w + static_cast<std::size_t>(c) * 9ULL;
        const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
        float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;

        for (int y = 0; y < N; y++) {
            dst[y] = dwconv3x3_cell(src, wc, 0, y);
            dst[(N - 1) * N + y] = dwconv3x3_cell(src, wc, N - 1, y);
        }

        const __m256 w0 = _mm256_set1_ps(wc[0]);
        const __m256 w1 = _mm256_set1_ps(wc[1]);
        const __m256 w2 = _mm256_set1_ps(wc[2]);
        const __m256 w3 = _mm256_set1_ps(wc[3]);
        const __m256 w4 = _mm256_set1_ps(wc[4]);
        const __m256 w5 = _mm256_set1_ps(wc[5]);
        const __m256 w6 = _mm256_set1_ps(wc[6]);
        const __m256 w7 = _mm256_set1_ps(wc[7]);
        const __m256 w8 = _mm256_set1_ps(wc[8]);

        for (int x = 1; x < N - 1; x++) {
            const int row = x * N;
            dst[row] = dwconv3x3_cell(src, wc, x, 0);

            int y = 1;
            for (; y + 7 < N - 1; y += 8) {
                const int top = (x - 1) * N + (y - 1);
                const int mid = x * N + (y - 1);
                const int bot = (x + 1) * N + (y - 1);

                __m256 s = _mm256_setzero_ps();
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 0), w0, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 1), w1, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 2), w2, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 0), w3, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 1), w4, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 2), w5, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 0), w6, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 1), w7, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 2), w8, s);
                _mm256_storeu_ps(dst + row + y, s);
            }
            for (; y < N - 1; y++) {
                const int idx = row + y;
                dst[idx] = src[idx - N - 1] * wc[0] + src[idx - N] * wc[1] + src[idx - N + 1] * wc[2] +
                           src[idx - 1] * wc[3] + src[idx] * wc[4] + src[idx + 1] * wc[5] +
                           src[idx + N - 1] * wc[6] + src[idx + N] * wc[7] + src[idx + N + 1] * wc[8];
            }

            dst[row + (N - 1)] = dwconv3x3_cell(src, wc, x, N - 1);
        }
    }
}

__attribute__((target("avx2,fma")))
static inline __m256 silu_avx2(__m256 x) {
#if AHC061_EXP002_FAST_SILU == 1
    const __m256 one = _mm256_set1_ps(1.0F);
    const __m256 half = _mm256_set1_ps(0.5F);
    const __m256 sign_mask = _mm256_set1_ps(-0.0F);
    const __m256 ax = _mm256_andnot_ps(sign_mask, x);
    const __m256 sig = _mm256_mul_ps(half, _mm256_add_ps(_mm256_div_ps(x, _mm256_add_ps(one, ax)), one));
    return _mm256_mul_ps(x, sig);
#elif AHC061_EXP002_FAST_SILU == 2
    static_assert(kSiluLutSize >= 3, "silu lut size must be >= 3");
    const auto& lut = silu_lut_table();
    const float* lut_ptr = lut.data();
    const __m256 vmin = _mm256_set1_ps(kSiluLutMin);
    const __m256 vmax = _mm256_set1_ps(kSiluLutMax);
    const __m256 vscale = _mm256_set1_ps(static_cast<float>(kSiluLutSize - 1) / (kSiluLutMax - kSiluLutMin));
    __m256 xc = _mm256_min_ps(vmax, _mm256_max_ps(vmin, x));
    __m256 pos = _mm256_mul_ps(_mm256_sub_ps(xc, vmin), vscale);
    __m256 pos_floor = _mm256_floor_ps(pos);
    __m256i idx = _mm256_cvttps_epi32(pos_floor);
    idx = _mm256_min_epi32(idx, _mm256_set1_epi32(kSiluLutSize - 2));
    __m256 frac = _mm256_sub_ps(pos, _mm256_cvtepi32_ps(idx));
    __m256 s0 = _mm256_i32gather_ps(lut_ptr, idx, 4);
    __m256 s1 = _mm256_i32gather_ps(lut_ptr, _mm256_add_epi32(idx, _mm256_set1_epi32(1)), 4);
    __m256 s = _mm256_fmadd_ps(_mm256_sub_ps(s1, s0), frac, s0);
    return _mm256_mul_ps(x, s);
#else
    alignas(32) float xv[8];
    alignas(32) float yv[8];
    _mm256_store_ps(xv, x);
    for (int i = 0; i < 8; i++) {
        yv[i] = silu(xv[i]);
    }
    return _mm256_load_ps(yv);
#endif
}

__attribute__((target("avx2,fma")))
static void group_norm_avx2(
    const float* in,
    int channels,
    int groups,
    const float* gn_w,
    const float* gn_b,
    float* out,
    bool apply_silu) {
    const int c_per_group = channels / groups;
    constexpr float kEps = 1.0e-5F;
    constexpr int kVec = (CELL_MAX / 8) * 8;

    for (int g = 0; g < groups; g++) {
        const int c0 = g * c_per_group;
        const int c1 = c0 + c_per_group;

        __m256 sum_v = _mm256_setzero_ps();
        __m256 sq_v = _mm256_setzero_ps();
        float sum_tail = 0.0F;
        float sq_tail = 0.0F;
        for (int c = c0; c < c1; c++) {
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            int i = 0;
            for (; i < kVec; i += 8) {
                const __m256 v = _mm256_loadu_ps(src + i);
                sum_v = _mm256_add_ps(sum_v, v);
                sq_v = _mm256_fmadd_ps(v, v, sq_v);
            }
            for (; i < CELL_MAX; i++) {
                const float v = src[i];
                sum_tail += v;
                sq_tail += v * v;
            }
        }

        float sum = hsum256_ps(sum_v) + sum_tail;
        float sq = hsum256_ps(sq_v) + sq_tail;
        const float inv_n = 1.0F / static_cast<float>(c_per_group * CELL_MAX);
        const float mean = sum * inv_n;
        float var = sq * inv_n - mean * mean;
        if (var < 0.0F)
            var = 0.0F;
        const float inv_std = 1.0F / std::sqrt(var + kEps);

        const __m256 vmean = _mm256_set1_ps(mean);
        const __m256 vstd = _mm256_set1_ps(inv_std);
        for (int c = c0; c < c1; c++) {
            const float gw = gn_w[c];
            const float gb = gn_b[c];
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;

            if (apply_silu) {
#if AHC061_EXP002_FAST_SILU == 0
                for (int i = 0; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    v = v * gw + gb;
                    dst[i] = silu(v);
                }
#else
                const __m256 vgw = _mm256_set1_ps(gw);
                const __m256 vgb = _mm256_set1_ps(gb);
                int i = 0;
                for (; i < kVec; i += 8) {
                    __m256 v = _mm256_loadu_ps(src + i);
                    v = _mm256_mul_ps(_mm256_sub_ps(v, vmean), vstd);
                    v = _mm256_fmadd_ps(v, vgw, vgb);
                    v = silu_avx2(v);
                    _mm256_storeu_ps(dst + i, v);
                }
                for (; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    v = v * gw + gb;
                    dst[i] = silu(v);
                }
#endif
            } else {
                const __m256 vgw = _mm256_set1_ps(gw);
                const __m256 vgb = _mm256_set1_ps(gb);
                int i = 0;
                for (; i < kVec; i += 8) {
                    __m256 v = _mm256_loadu_ps(src + i);
                    v = _mm256_mul_ps(_mm256_sub_ps(v, vmean), vstd);
                    v = _mm256_fmadd_ps(v, vgw, vgb);
                    _mm256_storeu_ps(dst + i, v);
                }
                for (; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    dst[i] = v * gw + gb;
                }
            }
        }
    }
}

__attribute__((target("avx2,fma")))
static void add_silu_inplace_avx2(float* x, const float* z, std::size_t n) {
#if AHC061_EXP002_FAST_SILU == 0
    for (std::size_t i = 0; i < n; i++) {
        x[i] = silu(x[i] + z[i]);
    }
#else
    std::size_t i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256 v = _mm256_add_ps(_mm256_loadu_ps(x + i), _mm256_loadu_ps(z + i));
        v = silu_avx2(v);
        _mm256_storeu_ps(x + i, v);
    }
    for (; i < n; i++) {
        x[i] = silu(x[i] + z[i]);
    }
#endif
}
#endif

static void add_silu_inplace(float* x, const float* z, std::size_t n) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        add_silu_inplace_avx2(x, z, n);
        return;
    }
#endif
    for (std::size_t i = 0; i < n; i++) {
        x[i] = silu(x[i] + z[i]);
    }
}

static void dwconv3x3(const float* in, int channels, const float* w, float* out) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        dwconv3x3_avx2(in, channels, w, out);
        return;
    }
#endif
    for (int c = 0; c < channels; c++) {
        const float* wc = w + static_cast<std::size_t>(c) * 9ULL;
        const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
        float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;
        for (int y = 0; y < N; y++) {
            dst[y] = dwconv3x3_cell(src, wc, 0, y);
            dst[(N - 1) * N + y] = dwconv3x3_cell(src, wc, N - 1, y);
        }
        for (int x = 1; x < N - 1; x++) {
            const int row = x * N;
            dst[row] = dwconv3x3_cell(src, wc, x, 0);
            for (int y = 1; y < N - 1; y++) {
                const int idx = row + y;
                dst[idx] = src[idx - N - 1] * wc[0] + src[idx - N] * wc[1] + src[idx - N + 1] * wc[2] +
                           src[idx - 1] * wc[3] + src[idx] * wc[4] + src[idx + 1] * wc[5] +
                           src[idx + N - 1] * wc[6] + src[idx + N] * wc[7] + src[idx + N + 1] * wc[8];
            }
            dst[row + (N - 1)] = dwconv3x3_cell(src, wc, x, N - 1);
        }
    }
}

static void group_norm(
    const float* in,
    int channels,
    int groups,
    const float* gn_w,
    const float* gn_b,
    float* out,
    bool apply_silu) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        group_norm_avx2(in, channels, groups, gn_w, gn_b, out, apply_silu);
        return;
    }
#endif
    const int c_per_group = channels / groups;
    constexpr float kEps = 1.0e-5F;
    for (int g = 0; g < groups; g++) {
        const int c0 = g * c_per_group;
        const int c1 = c0 + c_per_group;
        float sum = 0.0F;
        float sq = 0.0F;
        for (int c = c0; c < c1; c++) {
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                const float v = src[i];
                sum += v;
                sq += v * v;
            }
        }
        const float inv_n = 1.0F / static_cast<float>(c_per_group * CELL_MAX);
        const float mean = sum * inv_n;
        float var = sq * inv_n - mean * mean;
        if (var < 0.0F)
            var = 0.0F;
        const float inv_std = 1.0F / std::sqrt(var + kEps);
        for (int c = c0; c < c1; c++) {
            const float gw = gn_w[c];
            const float gb = gn_b[c];
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                float v = (src[i] - mean) * inv_std;
                v = v * gw + gb;
                dst[i] = apply_silu ? silu(v) : v;
            }
        }
    }
}

#ifndef AHC061_EXP002_TTA_MODE
// 0: no TTA
// 1: sum-prob   argmax_a log(sum_k p_k(a))
// 2: prod-prob  argmax_a sum_k log p_k(a)
// 3: avg-logit  argmax_a mean_k logits_k(a)
#define AHC061_EXP002_TTA_MODE 0
#endif

#ifndef AHC061_EXP002_TTA_K
#define AHC061_EXP002_TTA_K 2
#endif

static constexpr int kTtaMode = AHC061_EXP002_TTA_MODE;
static constexpr int kTtaKRaw = AHC061_EXP002_TTA_K;
static constexpr int kTtaK = (kTtaKRaw < 1) ? 1 : ((kTtaKRaw > 8) ? 8 : kTtaKRaw);

static inline float logaddexp(float a, float b) {
    const float neg_inf = -std::numeric_limits<float>::infinity();
    if (a == neg_inf)
        return b;
    if (b == neg_inf)
        return a;
    if (a < b)
        std::swap(a, b);
    return a + static_cast<float>(std::log1p(std::exp(static_cast<double>(b - a))));
}

static const std::array<std::array<std::uint8_t, CELL_MAX>, 8>& tta_perm() {
    static const std::array<std::array<std::uint8_t, CELL_MAX>, 8> p = [] {
        std::array<std::array<std::uint8_t, CELL_MAX>, 8> out{};
        for (int flip = 0; flip < 2; flip++) {
            for (int rot = 0; rot < 4; rot++) {
                const int k = flip * 4 + rot;
                for (int x = 0; x < N; x++) {
                    for (int y = 0; y < N; y++) {
                        int tx = x;
                        int ty = y;
                        if (flip)
                            ty = N - 1 - ty;
                        for (int r = 0; r < rot; r++) {
                            const int nx = ty;
                            const int ny = N - 1 - tx;
                            tx = nx;
                            ty = ny;
                        }
                        out[static_cast<std::size_t>(k)][static_cast<std::size_t>(cell_index(x, y))] =
                            static_cast<std::uint8_t>(cell_index(tx, ty));
                    }
                }
            }
        }
        return out;
    }();
    return p;
}

static void run_policy_logits(
    const CompactModel& model,
    const std::array<float, FEATURE_INPUT_C * CELL_MAX>& board,
    std::array<float, CELL_MAX>& out_logits) {
    std::array<float, HIDDEN_C * CELL_MAX> x;
    std::array<float, HIDDEN_C * CELL_MAX> y;
    std::array<float, HIDDEN_C * CELL_MAX> z;

    conv1x1_rank1(board.data(), model.in_channels, model.hidden, model.stem_w.data(), y.data());
    group_norm(y.data(), model.hidden, model.gn_groups, model.stem_gn_w.data(), model.stem_gn_b.data(), x.data(), true);

    const std::size_t hidden = static_cast<std::size_t>(model.hidden);
    for (int b = 0; b < model.blocks; b++) {
        const std::size_t b_off_h = static_cast<std::size_t>(b) * hidden;
        const std::size_t b_off_dw = b_off_h * 9ULL;
        const std::size_t b_off_pw = b_off_h * hidden;

        dwconv3x3(x.data(), model.hidden, model.dw_w.data() + b_off_dw, y.data());
        group_norm(
            y.data(),
            model.hidden,
            model.gn_groups,
            model.dw_gn_w.data() + b_off_h,
            model.dw_gn_b.data() + b_off_h,
            y.data(),
            true);

        conv1x1_rank1(y.data(), model.hidden, model.hidden, model.pw_w.data() + b_off_pw, z.data());
        group_norm(
            z.data(),
            model.hidden,
            model.gn_groups,
            model.pw_gn_w.data() + b_off_h,
            model.pw_gn_b.data() + b_off_h,
            z.data(),
            false);

        add_silu_inplace(x.data(), z.data(), x.size());
    }

    policy_linear(x.data(), model.hidden, model.policy_w.data(), model.policy_b, out_logits.data());
}

static int select_action(
    const CompactModel& model,
    const std::array<float, FEATURE_INPUT_C * CELL_MAX>& board,
    const std::array<std::uint8_t, CELL_MAX>& mask) {
    std::array<std::uint8_t, CELL_MAX> legal{};
    int legal_n = 0;
    for (int idx = 0; idx < CELL_MAX; idx++) {
        if (mask[static_cast<std::size_t>(idx)]) {
            legal[static_cast<std::size_t>(legal_n++)] = static_cast<std::uint8_t>(idx);
        }
    }
    if (legal_n == 0) {
        return cell_index(0, 0);
    }

    if (kTtaMode == 0) {
        std::array<float, CELL_MAX> logits;
        run_policy_logits(model, board, logits);

        int best = static_cast<int>(legal[0]);
        float best_v = -std::numeric_limits<float>::infinity();
        for (int li = 0; li < legal_n; li++) {
            const int idx = static_cast<int>(legal[static_cast<std::size_t>(li)]);
            const float v = logits[static_cast<std::size_t>(idx)];
            if (v > best_v) {
                best = idx;
                best_v = v;
            }
        }
        return best;
    }

    const auto& p = tta_perm();
    const float neg_inf = -std::numeric_limits<float>::infinity();

    std::array<float, CELL_MAX> acc{};
    if (kTtaMode == 1) {
        acc.fill(neg_inf);
    } else {
        acc.fill(0.0F);
    }

    std::array<float, FEATURE_INPUT_C * CELL_MAX> board_t;
    std::array<float, CELL_MAX> logits_t;
    std::array<std::array<std::uint8_t, CELL_MAX>, 8> legal_t{};
    for (int k = 0; k < kTtaK; k++) {
        const auto& pk = p[static_cast<std::size_t>(k)];
        for (int li = 0; li < legal_n; li++) {
            const std::uint8_t idx = legal[static_cast<std::size_t>(li)];
            legal_t[static_cast<std::size_t>(k)][static_cast<std::size_t>(li)] = pk[static_cast<std::size_t>(idx)];
        }
    }

    for (int k = 0; k < kTtaK; k++) {
        const auto& pk = p[static_cast<std::size_t>(k)];
        if (k == 0) {
            run_policy_logits(model, board, logits_t);
        } else {
            for (int c = 0; c < FEATURE_INPUT_C; c++) {
                const float* src = board.data() + static_cast<std::size_t>(c) * CELL_MAX;
                float* dst = board_t.data() + static_cast<std::size_t>(c) * CELL_MAX;
                for (int idx = 0; idx < CELL_MAX; idx++) {
                    const int idx_t = pk[static_cast<std::size_t>(idx)];
                    dst[static_cast<std::size_t>(idx_t)] = src[static_cast<std::size_t>(idx)];
                }
            }
            run_policy_logits(model, board_t, logits_t);
        }
        const std::uint8_t* idx_t_legal = legal_t[static_cast<std::size_t>(k)].data();

        if (kTtaMode == 3) {
            for (int li = 0; li < legal_n; li++) {
                const int idx = static_cast<int>(legal[static_cast<std::size_t>(li)]);
                const int idx_t = idx_t_legal[static_cast<std::size_t>(li)];
                acc[static_cast<std::size_t>(idx)] += logits_t[static_cast<std::size_t>(idx_t)];
            }
            continue;
        }

        float max_v = neg_inf;
        for (int li = 0; li < legal_n; li++) {
            const int idx_t = idx_t_legal[static_cast<std::size_t>(li)];
            max_v = std::max(max_v, logits_t[static_cast<std::size_t>(idx_t)]);
        }

        double sum = 0.0;
        for (int li = 0; li < legal_n; li++) {
            const int idx_t = idx_t_legal[static_cast<std::size_t>(li)];
            sum += std::exp(static_cast<double>(logits_t[static_cast<std::size_t>(idx_t)] - max_v));
        }
        const float logz = max_v + static_cast<float>(std::log(sum));

        for (int li = 0; li < legal_n; li++) {
            const int idx = static_cast<int>(legal[static_cast<std::size_t>(li)]);
            const int idx_t = idx_t_legal[static_cast<std::size_t>(li)];
            const float v = logits_t[static_cast<std::size_t>(idx_t)] - logz;
            if (kTtaMode == 1) {
                acc[static_cast<std::size_t>(idx)] = logaddexp(acc[static_cast<std::size_t>(idx)], v);
            } else {
                acc[static_cast<std::size_t>(idx)] += v;
            }
        }
    }

    int best = static_cast<int>(legal[0]);
    float best_v = neg_inf;
    for (int li = 0; li < legal_n; li++) {
        const int idx = static_cast<int>(legal[static_cast<std::size_t>(li)]);
        const float v = acc[static_cast<std::size_t>(idx)];
        if (v > best_v) {
            best = idx;
            best_v = v;
        }
    }
    return best;
}

static inline void extract_features_selected_into(
    const State& st,
    int turn,
    const std::array<ParticleFilterSMC, M_MAX>* pf,
    bool pf_enabled,
    float* out_board,             // [FEATURE_INPUT_C][100]
    std::uint8_t* out_action_mask // [100]
) {
    std::array<std::array<std::uint8_t, CELL_MAX>, M_MAX> comp{};
    std::array<std::array<std::uint8_t, CELL_MAX>, M_MAX> reach{};
    std::array<std::array<int, CELL_MAX>, M_MAX> moves{};
    std::array<int, M_MAX> move_cnt{};
    FeatureCommon common{};
    compute_feature_common_into(st, turn, pf, pf_enabled, common, out_action_mask, moves, move_cnt, comp, reach);
    write_features_from_common(common, out_board);
}

}  // namespace ahc061::exp002

int main() {
    using namespace std;
    using namespace ahc061::exp002;

    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 0, m = 0, t_max = 0, u_max = 0;
    if (!(cin >> n >> m >> t_max >> u_max))
        return 0;
    if (n != N) {
        cerr << "[ERROR] unexpected N=" << n << '\n';
        return 0;
    }
    if (m < 2 || m > M_MAX) {
        cerr << "[ERROR] unexpected M=" << m << '\n';
        return 0;
    }

    State st{};
    st.m = m;
    st.t_max = t_max;
    st.u_max = u_max;

    for (int x = 0; x < N; x++) {
        for (int y = 0; y < N; y++) {
            int v = 0;
            cin >> v;
            st.value[cell_index(x, y)] = v;
        }
    }

    for (int p = 0; p < m; p++) {
        int sx = 0, sy = 0;
        cin >> sx >> sy;
        st.ex[p] = static_cast<std::uint8_t>(sx);
        st.ey[p] = static_cast<std::uint8_t>(sy);
    }
    st.owner.fill(-1);
    st.level.fill(0);
    for (int p = 0; p < m; p++) {
        const int idx = cell_index(static_cast<int>(st.ex[p]), static_cast<int>(st.ey[p]));
        st.owner[idx] = static_cast<std::int8_t>(p);
        st.level[idx] = 1;
    }

    const std::uint64_t base_seed = compute_case_seed_for_pf(st);
    std::array<ParticleFilterSMC, M_MAX> pf{};
    for (int p = 0; p < m; p++) {
        const std::uint64_t s = base_seed ^ (static_cast<std::uint64_t>(p + 1) * 0x9e3779b97f4a7c15ULL) ^ 0x243f6a8885a308d3ULL;
        pf[p].reset(s);
    }

    static_assert(static_cast<std::size_t>(FEATURE_INPUT_C) == kModelMeta_in_channels, "feature/model in_channels mismatch");
    const CompactModel model = load_compact_model();

    for (int turn = 0; turn < t_max; turn++) {
        const State st_start = st;

        std::array<float, FEATURE_INPUT_C * CELL_MAX> board{};
        std::array<std::uint8_t, CELL_MAX> mask{};
        extract_features_selected_into(st, turn, &pf, true, board.data(), mask.data());

        const int action_cell = select_action(model, board, mask);
        const int ax = action_cell / N;
        const int ay = action_cell % N;
        cout << ax << ' ' << ay << '\n' << flush;

        std::array<int, M_MAX> tx{};
        std::array<int, M_MAX> ty{};
        for (int p = 0; p < m; p++) {
            cin >> tx[p] >> ty[p];
        }

        for (int p = 1; p < m; p++) {
            const int c = cell_index(tx[p], ty[p]);
            const MoveSummary sum = summarize_ai_observation(st_start, p, c);
            pf[p].update(sum);
        }

        for (int p = 0; p < m; p++) {
            int ex = 0, ey = 0;
            cin >> ex >> ey;
            st.ex[p] = static_cast<std::uint8_t>(ex);
            st.ey[p] = static_cast<std::uint8_t>(ey);
        }

        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                int o = 0;
                cin >> o;
                st.owner[cell_index(x, y)] = static_cast<std::int8_t>(o);
            }
        }
        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                int l = 0;
                cin >> l;
                st.level[cell_index(x, y)] = static_cast<std::uint8_t>(l);
            }
        }
    }

    return 0;
}
