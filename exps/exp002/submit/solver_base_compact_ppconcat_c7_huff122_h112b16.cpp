// exp002 submit (compact int8/fp16, no torch runtime)
// NOTE: This file is NOT a single-file submission by itself.
// Use make_submit_compact.py to bundle local headers + embed the model.

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <limits>
#include <string_view>
#include <vector>

#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
#include <immintrin.h>
#define AHC061_HAS_X86_AVX2_TARGET 1
#else
#define AHC061_HAS_X86_AVX2_TARGET 0
#endif

#include "ahc061/core/generator.hpp"
#include "ahc061/core/pf.hpp"
#include "ahc061/core/rules.hpp"
#include "ahc061/core/state.hpp"

// GENERATED by make_submit_compact.py (feature-specific).
#include "feature_config.inc"
#include "model_compact_encoded.inc"

namespace ahc061::exp002 {

static constexpr int HIDDEN_C = static_cast<int>(kModelMeta_hidden);
static constexpr int BLOCKS_N = static_cast<int>(kModelMeta_blocks);
static constexpr int IN_CHANNELS = static_cast<int>(kModelMeta_in_channels);
static constexpr int PLAYER_HIDDEN_C = static_cast<int>(kModelMeta_player_hidden);
static constexpr int FRONT_BLOCKS_N = (BLOCKS_N / 2 > 0) ? (BLOCKS_N / 2) : 1;
static constexpr int BACK_BLOCKS_N = BLOCKS_N - FRONT_BLOCKS_N;
static_assert(HIDDEN_C == 112, "c7/huff122 specialized template expects hidden=112");
static_assert(BLOCKS_N == 16, "c7/huff122 specialized template expects blocks=16");
static_assert(IN_CHANNELS == 149, "c7/huff122 specialized template expects in_channels=149");
static_assert(PLAYER_HIDDEN_C == 56, "c7/huff122 specialized template expects player_hidden=56");
static_assert(static_cast<int>(kModelMeta_payload_codec) == 1122, "c7/huff122 specialized template expects huff122 payload");

static std::string_view encoded_q_view() {
    return std::string_view(reinterpret_cast<const char*>(kModelQEncoded), sizeof(kModelQEncoded) - 1ULL);
}

static std::string_view encoded_h_view() {
    return std::string_view(reinterpret_cast<const char*>(kModelHEncoded), sizeof(kModelHEncoded) - 1ULL);
}

static constexpr int R4_GLOBAL_C = 19;
static constexpr int R4_PLAYER_PER_C = 16;
static constexpr int R4_PLAYER_BLOCK_C = M_MAX * R4_PLAYER_PER_C;
static constexpr int R4_TOTAL_C = R4_GLOBAL_C + R4_PLAYER_BLOCK_C + 2;
static constexpr int R4_M2_ONEHOT_OFFSET = 7;
static constexpr int PLAYER_BRANCH_N = M_MAX - 1;
static constexpr int PLAYER_COMMON_INPUT_C = R4_GLOBAL_C + R4_PLAYER_PER_C;
static constexpr int PLAYER_ENEMY_FEAT_INPUT_C = R4_PLAYER_PER_C;
static_assert(IN_CHANNELS == R4_TOTAL_C, "dwres_ppconcat_v1 expects research_v4(149ch)");
static_assert(PLAYER_BRANCH_N == 7, "PLAYER_BRANCH_N mismatch");

static std::vector<std::uint8_t> base122_decode(std::string_view s) {
    static constexpr std::array<std::uint8_t, 7> kIllegals = {0, 10, 13, 34, 38, 63, 92};
    static constexpr std::uint8_t kShortened = 7;
    std::vector<std::uint8_t> out;
    out.reserve(s.size());

    std::uint8_t cur_byte = 0;
    int bit_of_byte = 0;
    const auto push7 = [&](std::uint8_t seven) {
        const std::uint16_t byte = static_cast<std::uint16_t>(seven & 0x7FU) << 1;
        cur_byte |= static_cast<std::uint8_t>(byte >> bit_of_byte);
        bit_of_byte += 7;
        if (bit_of_byte >= 8) {
            out.push_back(cur_byte);
            bit_of_byte -= 8;
            cur_byte = static_cast<std::uint8_t>((byte << (7 - bit_of_byte)) & 0xFFU);
        }
    };

    for (std::size_t i = 0; i < s.size(); i++) {
        const std::uint8_t b0 = static_cast<std::uint8_t>(s[i]);
        std::uint16_t cp = 0;
        if ((b0 & 0x80U) == 0U) {
            cp = b0;
        } else {
            if ((b0 & 0xE0U) != 0xC0U || (i + 1) >= s.size())
                continue;
            const std::uint8_t b1 = static_cast<std::uint8_t>(s[++i]);
            if ((b1 & 0xC0U) != 0x80U)
                continue;
            cp = static_cast<std::uint16_t>(((b0 & 0x1FU) << 6) | (b1 & 0x3FU));
        }

        if (cp > 127U) {
            const std::uint8_t illegal_index = static_cast<std::uint8_t>((cp >> 8) & 0x07U);
            if (illegal_index != kShortened) {
                if (illegal_index >= kIllegals.size())
                    continue;
                push7(kIllegals[illegal_index]);
            }
            push7(static_cast<std::uint8_t>(cp & 0x7FU));
        } else {
            push7(static_cast<std::uint8_t>(cp));
        }
    }
    return out;
}

static std::vector<std::uint8_t> huff122_decompress(const std::vector<std::uint8_t>& blob, std::size_t expected_size) {
    std::vector<std::uint8_t> out;
    out.reserve(expected_size);
    if (expected_size == 0)
        return out;
    if (blob.size() < 256ULL)
        return {};

    struct SymLen {
        std::uint16_t sym;
        std::uint8_t len;
    };
    std::vector<SymLen> syms;
    syms.reserve(256);
    for (int s = 0; s < 256; s++) {
        const std::uint8_t ln = blob[static_cast<std::size_t>(s)];
        if (ln > 0) {
            syms.push_back(SymLen{static_cast<std::uint16_t>(s), ln});
        }
    }
    if (syms.empty())
        return {};

    std::sort(syms.begin(), syms.end(), [](const SymLen& a, const SymLen& b) {
        if (a.len != b.len)
            return a.len < b.len;
        return a.sym < b.sym;
    });

    std::vector<int> left(1, -1), right(1, -1), value(1, -1);
    std::uint64_t code = 0;
    int prev_len = 0;
    for (const SymLen sl : syms) {
        const int ln = static_cast<int>(sl.len);
        if (ln < prev_len || ln > 63)
            return {};
        code <<= static_cast<std::uint64_t>(ln - prev_len);
        int node = 0;
        for (int k = ln - 1; k >= 0; k--) {
            const int bit = static_cast<int>((code >> static_cast<unsigned>(k)) & 1ULL);
            int nxt = bit ? right[node] : left[node];
            if (nxt < 0) {
                nxt = static_cast<int>(value.size());
                left.push_back(-1);
                right.push_back(-1);
                value.push_back(-1);
                if (bit) {
                    right[node] = nxt;
                } else {
                    left[node] = nxt;
                }
            }
            node = nxt;
        }
        value[node] = static_cast<int>(sl.sym);
        code += 1ULL;
        prev_len = ln;
    }

    int node = 0;
    for (std::size_t i = 256ULL; i < blob.size(); i++) {
        const std::uint8_t by = blob[i];
        for (int k = 7; k >= 0; k--) {
            const int bit = static_cast<int>((by >> static_cast<unsigned>(k)) & 1U);
            node = bit ? right[node] : left[node];
            if (node < 0)
                return {};
            const int sym = value[node];
            if (sym >= 0) {
                out.push_back(static_cast<std::uint8_t>(sym));
                if (out.size() == expected_size)
                    return out;
                node = 0;
            }
        }
    }
    return {};
}

static std::vector<std::uint8_t> decode_payload(std::string_view s, std::size_t expected_size) {
    const std::vector<std::uint8_t> packed = base122_decode(s);
    return huff122_decompress(packed, expected_size);
}

static float half_to_float(std::uint16_t h) {
    const std::uint32_t sign = static_cast<std::uint32_t>(h & 0x8000U) << 16;
    std::uint32_t exp = static_cast<std::uint32_t>((h >> 10) & 0x1FU);
    std::uint32_t frac = static_cast<std::uint32_t>(h & 0x03FFU);
    std::uint32_t f = 0;

    if (exp == 0) {
        if (frac == 0) {
            f = sign;
        } else {
            exp = 1;
            while ((frac & 0x0400U) == 0U) {
                frac <<= 1;
                exp--;
            }
            frac &= 0x03FFU;
            f = sign | ((exp + 112U) << 23) | (frac << 13);
        }
    } else if (exp == 31) {
        f = sign | 0x7F800000U | (frac << 13);
    } else {
        f = sign | ((exp + 112U) << 23) | (frac << 13);
    }

    float out = 0.0F;
    std::memcpy(&out, &f, sizeof(float));
    return out;
}

static int pick_gn_groups(int channels) {
    for (int g : {8, 4, 2, 1}) {
        if (channels % g == 0)
            return g;
    }
    return 1;
}

struct CompactModel {
    int in_channels = 0;
    int hidden = 0;
    int blocks = 0;
    int front_blocks = 0;
    int back_blocks = 0;
    int player_hidden = 0;
    int gn_groups = 1;
    int player_gn_groups = 1;

    std::vector<float> main_stem_w;    // [C][H] (transposed)
    std::vector<float> main_stem_gn_w; // [H]
    std::vector<float> main_stem_gn_b; // [H]

    std::vector<float> main_front_dw_w;    // [F][H][9]
    std::vector<float> main_front_dw_gn_w; // [F][H]
    std::vector<float> main_front_dw_gn_b; // [F][H]
    std::vector<float> main_front_pw_w;    // [F][H][H] transposed
    std::vector<float> main_front_pw_gn_w; // [F][H]
    std::vector<float> main_front_pw_gn_b; // [F][H]

    std::vector<float> main_back_dw_w;    // [B][H][9]
    std::vector<float> main_back_dw_gn_w; // [B][H]
    std::vector<float> main_back_dw_gn_b; // [B][H]
    std::vector<float> main_back_pw_w;    // [B][H][H] transposed
    std::vector<float> main_back_pw_gn_w; // [B][H]
    std::vector<float> main_back_pw_gn_b; // [B][H]

    std::vector<float> player_stem_common_w; // [35][PH] transposed
    std::vector<float> player_stem_enemy_w;  // [16][PH] transposed
    std::vector<float> player_enemy_id;      // [7][PH]
    std::vector<float> player_stem_gn_w;     // [PH]
    std::vector<float> player_stem_gn_b;     // [PH]

    std::vector<float> player_front_dw_w;    // [F][PH][9]
    std::vector<float> player_front_dw_gn_w; // [F][PH]
    std::vector<float> player_front_dw_gn_b; // [F][PH]
    std::vector<float> player_front_pw_w;    // [F][PH][PH] transposed
    std::vector<float> player_front_pw_gn_w; // [F][PH]
    std::vector<float> player_front_pw_gn_b; // [F][PH]

    std::vector<float> merge_main_w;   // [H][H] transposed
    std::vector<float> merge_player_w; // [7*PH][H] transposed
    std::vector<float> merge_gn_w;     // [H]
    std::vector<float> merge_gn_b;     // [H]

    std::vector<float> policy_w; // [H]
    float policy_b = 0.0F;
};

static CompactModel load_compact_model() {
    const std::vector<std::uint8_t> q_bytes = decode_payload(encoded_q_view(), kModelMeta_q_bytes);
    const std::vector<std::uint8_t> h_bytes = decode_payload(encoded_h_view(), kModelMeta_h_bytes);

    if (q_bytes.size() != kModelMeta_q_bytes) {
        std::cerr << "[ERROR] q blob size mismatch decoded=" << q_bytes.size() << " meta=" << kModelMeta_q_bytes << '\n';
        std::exit(1);
    }
    if (h_bytes.size() != kModelMeta_h_bytes) {
        std::cerr << "[ERROR] h blob size mismatch decoded=" << h_bytes.size() << " meta=" << kModelMeta_h_bytes << '\n';
        std::exit(1);
    }
    if (q_bytes.size() != kModelMeta_q_count) {
        std::cerr << "[ERROR] q count mismatch decoded=" << q_bytes.size() << " expected=" << kModelMeta_q_count << '\n';
        std::exit(1);
    }
    if (h_bytes.size() != kModelMeta_h_count * 2ULL) {
        std::cerr << "[ERROR] h count mismatch decoded=" << h_bytes.size() << " expected=" << (kModelMeta_h_count * 2ULL) << '\n';
        std::exit(1);
    }

    std::vector<float> h_vals(kModelMeta_h_count);
    for (std::size_t i = 0; i < kModelMeta_h_count; i++) {
        const std::uint16_t bits = static_cast<std::uint16_t>(h_bytes[2 * i]) |
                                   (static_cast<std::uint16_t>(h_bytes[2 * i + 1]) << 8);
        h_vals[i] = half_to_float(bits);
    }

    CompactModel model{};
    model.in_channels = IN_CHANNELS;
    model.hidden = HIDDEN_C;
    model.blocks = BLOCKS_N;
    model.front_blocks = FRONT_BLOCKS_N;
    model.back_blocks = BACK_BLOCKS_N;
    model.player_hidden = PLAYER_HIDDEN_C;
    model.gn_groups = pick_gn_groups(model.hidden);
    model.player_gn_groups = pick_gn_groups(model.player_hidden);

    const std::size_t h = static_cast<std::size_t>(model.hidden);
    const std::size_t ph = static_cast<std::size_t>(model.player_hidden);
    const std::size_t f = static_cast<std::size_t>(model.front_blocks);
    const std::size_t bk = static_cast<std::size_t>(model.back_blocks);
    const std::size_t c = static_cast<std::size_t>(model.in_channels);

    model.main_stem_w.resize(c * h);
    model.main_stem_gn_w.resize(h);
    model.main_stem_gn_b.resize(h);

    model.main_front_dw_w.resize(f * h * 9ULL);
    model.main_front_dw_gn_w.resize(f * h);
    model.main_front_dw_gn_b.resize(f * h);
    model.main_front_pw_w.resize(f * h * h);
    model.main_front_pw_gn_w.resize(f * h);
    model.main_front_pw_gn_b.resize(f * h);

    model.main_back_dw_w.resize(bk * h * 9ULL);
    model.main_back_dw_gn_w.resize(bk * h);
    model.main_back_dw_gn_b.resize(bk * h);
    model.main_back_pw_w.resize(bk * h * h);
    model.main_back_pw_gn_w.resize(bk * h);
    model.main_back_pw_gn_b.resize(bk * h);

    model.player_stem_common_w.resize(static_cast<std::size_t>(PLAYER_COMMON_INPUT_C) * ph);
    model.player_stem_enemy_w.resize(static_cast<std::size_t>(PLAYER_ENEMY_FEAT_INPUT_C) * ph);
    model.player_enemy_id.resize(static_cast<std::size_t>(PLAYER_BRANCH_N) * ph);
    model.player_stem_gn_w.resize(ph);
    model.player_stem_gn_b.resize(ph);

    model.player_front_dw_w.resize(f * ph * 9ULL);
    model.player_front_dw_gn_w.resize(f * ph);
    model.player_front_dw_gn_b.resize(f * ph);
    model.player_front_pw_w.resize(f * ph * ph);
    model.player_front_pw_gn_w.resize(f * ph);
    model.player_front_pw_gn_b.resize(f * ph);

    model.merge_main_w.resize(h * h);
    model.merge_player_w.resize(static_cast<std::size_t>(PLAYER_BRANCH_N) * ph * h);
    model.merge_gn_w.resize(h);
    model.merge_gn_b.resize(h);
    model.policy_w.resize(h);

    std::size_t q_off = 0;
    std::size_t h_off = 0;

    const auto read_h = [&]() -> float {
        if (h_off >= h_vals.size()) {
            std::cerr << "[ERROR] h blob underflow while decoding\n";
            std::exit(1);
        }
        return h_vals[h_off++];
    };

    const auto read_q_i8_block = [&](std::vector<float>& dst, std::size_t off, std::size_t out_c, std::size_t in_c) {
        std::vector<float> scale(out_c);
        for (std::size_t oc = 0; oc < out_c; oc++) scale[oc] = read_h();
        for (std::size_t oc = 0; oc < out_c; oc++) {
            const float s = scale[oc];
            for (std::size_t ic = 0; ic < in_c; ic++) {
                if (q_off >= q_bytes.size()) {
                    std::cerr << "[ERROR] q blob underflow while decoding\n";
                    std::exit(1);
                }
                const std::int8_t qv = static_cast<std::int8_t>(q_bytes[q_off++]);
                dst[off + ic * out_c + oc] = static_cast<float>(qv) * s;
            }
        }
    };
    const auto read_aux_vec = [&](std::vector<float>& dst, std::size_t off, std::size_t n) {
        for (std::size_t i = 0; i < n; i++) dst[off + i] = read_h();
    };
    const auto read_dw_kernel = [&](std::vector<float>& dst, std::size_t ch, std::size_t block_idx) {
        const std::size_t bo = block_idx * ch;
        for (std::size_t ci = 0; ci < ch; ci++) {
            const std::size_t base = (bo + ci) * 9ULL;
            for (std::size_t k = 0; k < 9; k++) dst[base + k] = read_h();
        }
    };

    read_aux_vec(model.main_stem_w, 0, c * h);
    read_aux_vec(model.main_stem_gn_w, 0, h);
    read_aux_vec(model.main_stem_gn_b, 0, h);

    for (std::size_t bi = 0; bi < f; bi++) {
        const std::size_t bo = bi * h;
        const std::size_t bo_pw = bi * h * h;
        read_dw_kernel(model.main_front_dw_w, h, bi);
        read_aux_vec(model.main_front_dw_gn_w, bo, h);
        read_aux_vec(model.main_front_dw_gn_b, bo, h);
        read_q_i8_block(model.main_front_pw_w, bo_pw, h, h);
        read_aux_vec(model.main_front_pw_gn_w, bo, h);
        read_aux_vec(model.main_front_pw_gn_b, bo, h);
    }

    for (std::size_t bi = 0; bi < bk; bi++) {
        const std::size_t bo = bi * h;
        const std::size_t bo_pw = bi * h * h;
        read_dw_kernel(model.main_back_dw_w, h, bi);
        read_aux_vec(model.main_back_dw_gn_w, bo, h);
        read_aux_vec(model.main_back_dw_gn_b, bo, h);
        read_q_i8_block(model.main_back_pw_w, bo_pw, h, h);
        read_aux_vec(model.main_back_pw_gn_w, bo, h);
        read_aux_vec(model.main_back_pw_gn_b, bo, h);
    }

    read_aux_vec(model.player_stem_common_w, 0, static_cast<std::size_t>(PLAYER_COMMON_INPUT_C) * ph);
    read_aux_vec(model.player_stem_enemy_w, 0, static_cast<std::size_t>(PLAYER_ENEMY_FEAT_INPUT_C) * ph);
    read_aux_vec(model.player_enemy_id, 0, static_cast<std::size_t>(PLAYER_BRANCH_N) * ph);
    read_aux_vec(model.player_stem_gn_w, 0, ph);
    read_aux_vec(model.player_stem_gn_b, 0, ph);

    for (std::size_t bi = 0; bi < f; bi++) {
        const std::size_t bo = bi * ph;
        const std::size_t bo_dw = bo * 9ULL;
        const std::size_t bo_pw = bi * ph * ph;
        read_aux_vec(model.player_front_dw_w, bo_dw, ph * 9ULL);
        read_aux_vec(model.player_front_dw_gn_w, bo, ph);
        read_aux_vec(model.player_front_dw_gn_b, bo, ph);
        read_q_i8_block(model.player_front_pw_w, bo_pw, ph, ph);
        read_aux_vec(model.player_front_pw_gn_w, bo, ph);
        read_aux_vec(model.player_front_pw_gn_b, bo, ph);
    }
    read_q_i8_block(model.merge_main_w, 0, h, h);
    read_q_i8_block(model.merge_player_w, 0, h, static_cast<std::size_t>(PLAYER_BRANCH_N) * ph);
    read_aux_vec(model.merge_gn_w, 0, h);
    read_aux_vec(model.merge_gn_b, 0, h);
    read_aux_vec(model.policy_w, 0, h);
    model.policy_b = read_h();

    if (q_off != q_bytes.size()) {
        std::cerr << "[ERROR] q blob not fully consumed: used=" << q_off << " total=" << q_bytes.size() << '\n';
        std::exit(1);
    }
    if (h_off != h_vals.size()) {
        std::cerr << "[ERROR] h blob not fully consumed: used=" << h_off << " total=" << h_vals.size() << '\n';
        std::exit(1);
    }

    return model;
}

static inline float fast_sigmoid(float x) {
    const float ax = std::fabs(x);
    return 0.5F * (x / (1.0F + ax) + 1.0F);
}

#ifndef AHC061_EXP002_FAST_SILU
#define AHC061_EXP002_FAST_SILU 2
#endif

#if AHC061_EXP002_FAST_SILU == 2
#ifndef AHC061_EXP002_SILU_LUT_SIZE
#define AHC061_EXP002_SILU_LUT_SIZE 16385
#endif
#ifndef AHC061_EXP002_SILU_LUT_RANGE
#define AHC061_EXP002_SILU_LUT_RANGE 16.0F
#endif
static constexpr int kSiluLutSize = AHC061_EXP002_SILU_LUT_SIZE;
static constexpr float kSiluLutRange = AHC061_EXP002_SILU_LUT_RANGE;
static constexpr float kSiluLutMin = -kSiluLutRange;
static constexpr float kSiluLutMax = kSiluLutRange;
static const std::array<float, kSiluLutSize>& silu_lut_table() {
    static const std::array<float, kSiluLutSize> lut = [] {
        std::array<float, kSiluLutSize> t{};
        for (int i = 0; i < kSiluLutSize; i++) {
            const float x0 = kSiluLutMin +
                             (kSiluLutMax - kSiluLutMin) * static_cast<float>(i) / static_cast<float>(kSiluLutSize - 1);
            t[static_cast<std::size_t>(i)] = 1.0F / (1.0F + std::exp(-x0));
        }
        return t;
    }();
    return lut;
}
static inline float silu_lut_scalar(float x) {
    const auto& lut = silu_lut_table();
    if (x <= kSiluLutMin)
        return x * lut[0];
    if (x >= kSiluLutMax)
        return x * lut[kSiluLutSize - 1];
    const float pos = (x - kSiluLutMin) * static_cast<float>(kSiluLutSize - 1) / (kSiluLutMax - kSiluLutMin);
    const int idx = static_cast<int>(pos);
    const float frac = pos - static_cast<float>(idx);
    const float s0 = lut[static_cast<std::size_t>(idx)];
    const float s1 = lut[static_cast<std::size_t>(idx + 1)];
    return x * (s0 + (s1 - s0) * frac);
}
#endif

static inline float silu(float x) {
#if AHC061_EXP002_FAST_SILU == 1
    return x * fast_sigmoid(x);
#elif AHC061_EXP002_FAST_SILU == 2
    return silu_lut_scalar(x);
#else
    return x / (1.0F + std::exp(-x));
#endif
}

#if AHC061_HAS_X86_AVX2_TARGET
static inline bool can_use_avx2() {
    static int cached = -1;
    if (cached < 0) {
#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
        cached = (__builtin_cpu_supports("avx2") && __builtin_cpu_supports("fma")) ? 1 : 0;
#else
        cached = 0;
#endif
    }
    return cached != 0;
}

__attribute__((target("avx2,fma")))
static void conv1x1_rank1_avx2(const float* in, int in_channels, int out_channels, const float* w_t, float* out) {
    constexpr int kVec = (CELL_MAX / 8) * 8;
    if ((out_channels & 7) != 0) {
        for (int oc = 0; oc < out_channels; oc++) {
            float* dst = out + static_cast<std::size_t>(oc) * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                float s = 0.0F;
                for (int ic = 0; ic < in_channels; ic++) {
                    const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                    const float w0 = w_t[static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) +
                                         static_cast<std::size_t>(oc)];
                    s += v * w0;
                }
                dst[i] = s;
            }
        }
        return;
    }
    for (int oc = 0; oc < out_channels; oc += 8) {
        float* d0 = out + static_cast<std::size_t>(oc + 0) * CELL_MAX;
        float* d1 = out + static_cast<std::size_t>(oc + 1) * CELL_MAX;
        float* d2 = out + static_cast<std::size_t>(oc + 2) * CELL_MAX;
        float* d3 = out + static_cast<std::size_t>(oc + 3) * CELL_MAX;
        float* d4 = out + static_cast<std::size_t>(oc + 4) * CELL_MAX;
        float* d5 = out + static_cast<std::size_t>(oc + 5) * CELL_MAX;
        float* d6 = out + static_cast<std::size_t>(oc + 6) * CELL_MAX;
        float* d7 = out + static_cast<std::size_t>(oc + 7) * CELL_MAX;
        int i = 0;
        for (; i < kVec; i += 8) {
            __m256 acc0 = _mm256_setzero_ps();
            __m256 acc1 = _mm256_setzero_ps();
            __m256 acc2 = _mm256_setzero_ps();
            __m256 acc3 = _mm256_setzero_ps();
            __m256 acc4 = _mm256_setzero_ps();
            __m256 acc5 = _mm256_setzero_ps();
            __m256 acc6 = _mm256_setzero_ps();
            __m256 acc7 = _mm256_setzero_ps();
            for (int ic = 0; ic < in_channels; ic++) {
                const float* src = in + static_cast<std::size_t>(ic) * CELL_MAX + i;
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                const __m256 s = _mm256_loadu_ps(src);
                acc0 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[0]), acc0);
                acc1 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[1]), acc1);
                acc2 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[2]), acc2);
                acc3 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[3]), acc3);
                acc4 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[4]), acc4);
                acc5 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[5]), acc5);
                acc6 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[6]), acc6);
                acc7 = _mm256_fmadd_ps(s, _mm256_set1_ps(wr[7]), acc7);
            }
            _mm256_storeu_ps(d0 + i, acc0);
            _mm256_storeu_ps(d1 + i, acc1);
            _mm256_storeu_ps(d2 + i, acc2);
            _mm256_storeu_ps(d3 + i, acc3);
            _mm256_storeu_ps(d4 + i, acc4);
            _mm256_storeu_ps(d5 + i, acc5);
            _mm256_storeu_ps(d6 + i, acc6);
            _mm256_storeu_ps(d7 + i, acc7);
        }
        for (; i < CELL_MAX; i++) {
            float s0 = 0.0F;
            float s1 = 0.0F;
            float s2 = 0.0F;
            float s3 = 0.0F;
            float s4 = 0.0F;
            float s5 = 0.0F;
            float s6 = 0.0F;
            float s7 = 0.0F;
            for (int ic = 0; ic < in_channels; ic++) {
                const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                const float* wr = w_t + static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + oc;
                s0 += v * wr[0];
                s1 += v * wr[1];
                s2 += v * wr[2];
                s3 += v * wr[3];
                s4 += v * wr[4];
                s5 += v * wr[5];
                s6 += v * wr[6];
                s7 += v * wr[7];
            }
            d0[i] = s0;
            d1[i] = s1;
            d2[i] = s2;
            d3[i] = s3;
            d4[i] = s4;
            d5[i] = s5;
            d6[i] = s6;
            d7[i] = s7;
        }
    }
}
#endif

// 1x1 conv using rank-1 accumulation:
// out[oc, idx] = sum_ic in[ic, idx] * w_t[ic, oc]
static void conv1x1_rank1(const float* in, int in_channels, int out_channels, const float* w_t, float* out) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        conv1x1_rank1_avx2(in, in_channels, out_channels, w_t, out);
        return;
    }
#endif
    for (int oc = 0; oc < out_channels; oc++) {
        float* dst = out + static_cast<std::size_t>(oc) * CELL_MAX;
        for (int i = 0; i < CELL_MAX; i++) {
            float s = 0.0F;
            for (int ic = 0; ic < in_channels; ic++) {
                const float v = in[static_cast<std::size_t>(ic) * CELL_MAX + i];
                const float w0 = w_t[static_cast<std::size_t>(ic) * static_cast<std::size_t>(out_channels) + static_cast<std::size_t>(oc)];
                s += v * w0;
            }
            dst[i] = s;
        }
    }
}

#if AHC061_HAS_X86_AVX2_TARGET
__attribute__((target("avx2,fma")))
static void policy_linear_avx2(const float* x, int channels, const float* w, float bias, float* out_logits) {
    constexpr int kVec = (CELL_MAX / 8) * 8;
    int i = 0;
    const __m256 vbias = _mm256_set1_ps(bias);
    for (; i < kVec; i += 8) {
        _mm256_storeu_ps(out_logits + i, vbias);
    }
    for (; i < CELL_MAX; i++) {
        out_logits[i] = bias;
    }

    for (int c = 0; c < channels; c++) {
        const float wc = w[static_cast<std::size_t>(c)];
        const __m256 vw = _mm256_set1_ps(wc);
        const float* src = x + static_cast<std::size_t>(c) * CELL_MAX;
        int j = 0;
        for (; j < kVec; j += 8) {
            __m256 o = _mm256_loadu_ps(out_logits + j);
            const __m256 s = _mm256_loadu_ps(src + j);
            o = _mm256_fmadd_ps(s, vw, o);
            _mm256_storeu_ps(out_logits + j, o);
        }
        for (; j < CELL_MAX; j++) {
            out_logits[j] += src[j] * wc;
        }
    }
}
#endif

static void policy_linear(const float* x, int channels, const float* w, float bias, float* out_logits) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        policy_linear_avx2(x, channels, w, bias, out_logits);
        return;
    }
#endif
    for (int i = 0; i < CELL_MAX; i++) {
        out_logits[i] = bias;
    }
    for (int c = 0; c < channels; c++) {
        const float wc = w[static_cast<std::size_t>(c)];
        const float* src = x + static_cast<std::size_t>(c) * CELL_MAX;
        for (int i = 0; i < CELL_MAX; i++) {
            out_logits[i] += src[i] * wc;
        }
    }
}

static inline float dwconv3x3_cell(const float* src, const float* wc, int x, int y) {
    float s = 0.0F;
    int k = 0;
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            const int xx = x + dx;
            const int yy = y + dy;
            if (0 <= xx && xx < N && 0 <= yy && yy < N) {
                s += src[cell_index(xx, yy)] * wc[k];
            }
            k++;
        }
    }
    return s;
}

#if AHC061_HAS_X86_AVX2_TARGET
__attribute__((target("avx2,fma")))
static inline float hsum256_ps(__m256 v) {
    alignas(32) float tmp[8];
    _mm256_store_ps(tmp, v);
    return tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7];
}

__attribute__((target("avx2,fma")))
static void dwconv3x3_avx2(const float* in, int channels, const float* w, float* out) {
    for (int c = 0; c < channels; c++) {
        const float* wc = w + static_cast<std::size_t>(c) * 9ULL;
        const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
        float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;

        for (int y = 0; y < N; y++) {
            dst[y] = dwconv3x3_cell(src, wc, 0, y);
            dst[(N - 1) * N + y] = dwconv3x3_cell(src, wc, N - 1, y);
        }

        const __m256 w0 = _mm256_set1_ps(wc[0]);
        const __m256 w1 = _mm256_set1_ps(wc[1]);
        const __m256 w2 = _mm256_set1_ps(wc[2]);
        const __m256 w3 = _mm256_set1_ps(wc[3]);
        const __m256 w4 = _mm256_set1_ps(wc[4]);
        const __m256 w5 = _mm256_set1_ps(wc[5]);
        const __m256 w6 = _mm256_set1_ps(wc[6]);
        const __m256 w7 = _mm256_set1_ps(wc[7]);
        const __m256 w8 = _mm256_set1_ps(wc[8]);

        for (int x = 1; x < N - 1; x++) {
            const int row = x * N;
            dst[row] = dwconv3x3_cell(src, wc, x, 0);

            int y = 1;
            for (; y + 7 < N - 1; y += 8) {
                const int top = (x - 1) * N + (y - 1);
                const int mid = x * N + (y - 1);
                const int bot = (x + 1) * N + (y - 1);

                __m256 s = _mm256_setzero_ps();
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 0), w0, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 1), w1, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + top + 2), w2, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 0), w3, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 1), w4, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + mid + 2), w5, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 0), w6, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 1), w7, s);
                s = _mm256_fmadd_ps(_mm256_loadu_ps(src + bot + 2), w8, s);
                _mm256_storeu_ps(dst + row + y, s);
            }
            for (; y < N - 1; y++) {
                const int idx = row + y;
                dst[idx] = src[idx - N - 1] * wc[0] + src[idx - N] * wc[1] + src[idx - N + 1] * wc[2] +
                           src[idx - 1] * wc[3] + src[idx] * wc[4] + src[idx + 1] * wc[5] +
                           src[idx + N - 1] * wc[6] + src[idx + N] * wc[7] + src[idx + N + 1] * wc[8];
            }

            dst[row + (N - 1)] = dwconv3x3_cell(src, wc, x, N - 1);
        }
    }
}

__attribute__((target("avx2,fma")))
static inline __m256 silu_avx2(__m256 x) {
#if AHC061_EXP002_FAST_SILU == 1
    const __m256 one = _mm256_set1_ps(1.0F);
    const __m256 half = _mm256_set1_ps(0.5F);
    const __m256 sign_mask = _mm256_set1_ps(-0.0F);
    const __m256 ax = _mm256_andnot_ps(sign_mask, x);
    const __m256 sig = _mm256_mul_ps(half, _mm256_add_ps(_mm256_div_ps(x, _mm256_add_ps(one, ax)), one));
    return _mm256_mul_ps(x, sig);
#elif AHC061_EXP002_FAST_SILU == 2
    static_assert(kSiluLutSize >= 3, "silu lut size must be >= 3");
    const auto& lut = silu_lut_table();
    const float* lut_ptr = lut.data();
    const __m256 vmin = _mm256_set1_ps(kSiluLutMin);
    const __m256 vmax = _mm256_set1_ps(kSiluLutMax);
    const __m256 vscale = _mm256_set1_ps(static_cast<float>(kSiluLutSize - 1) / (kSiluLutMax - kSiluLutMin));
    __m256 xc = _mm256_min_ps(vmax, _mm256_max_ps(vmin, x));
    __m256 pos = _mm256_mul_ps(_mm256_sub_ps(xc, vmin), vscale);
    __m256 pos_floor = _mm256_floor_ps(pos);
    __m256i idx = _mm256_cvttps_epi32(pos_floor);
    idx = _mm256_min_epi32(idx, _mm256_set1_epi32(kSiluLutSize - 2));
    __m256 frac = _mm256_sub_ps(pos, _mm256_cvtepi32_ps(idx));
    __m256 s0 = _mm256_i32gather_ps(lut_ptr, idx, 4);
    __m256 s1 = _mm256_i32gather_ps(lut_ptr, _mm256_add_epi32(idx, _mm256_set1_epi32(1)), 4);
    __m256 s = _mm256_fmadd_ps(_mm256_sub_ps(s1, s0), frac, s0);
    return _mm256_mul_ps(x, s);
#else
    alignas(32) float xv[8];
    alignas(32) float yv[8];
    _mm256_store_ps(xv, x);
    for (int i = 0; i < 8; i++) {
        yv[i] = silu(xv[i]);
    }
    return _mm256_load_ps(yv);
#endif
}

__attribute__((target("avx2,fma")))
static void group_norm_avx2(
    const float* in,
    int channels,
    int groups,
    const float* gn_w,
    const float* gn_b,
    float* out,
    bool apply_silu) {
    const int c_per_group = channels / groups;
    constexpr float kEps = 1.0e-5F;
    constexpr int kVec = (CELL_MAX / 8) * 8;

    for (int g = 0; g < groups; g++) {
        const int c0 = g * c_per_group;
        const int c1 = c0 + c_per_group;

        __m256 sum_v = _mm256_setzero_ps();
        __m256 sq_v = _mm256_setzero_ps();
        float sum_tail = 0.0F;
        float sq_tail = 0.0F;
        for (int c = c0; c < c1; c++) {
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            int i = 0;
            for (; i < kVec; i += 8) {
                const __m256 v = _mm256_loadu_ps(src + i);
                sum_v = _mm256_add_ps(sum_v, v);
                sq_v = _mm256_fmadd_ps(v, v, sq_v);
            }
            for (; i < CELL_MAX; i++) {
                const float v = src[i];
                sum_tail += v;
                sq_tail += v * v;
            }
        }

        float sum = hsum256_ps(sum_v) + sum_tail;
        float sq = hsum256_ps(sq_v) + sq_tail;
        const float inv_n = 1.0F / static_cast<float>(c_per_group * CELL_MAX);
        const float mean = sum * inv_n;
        float var = sq * inv_n - mean * mean;
        if (var < 0.0F)
            var = 0.0F;
        const float inv_std = 1.0F / std::sqrt(var + kEps);

        const __m256 vmean = _mm256_set1_ps(mean);
        const __m256 vstd = _mm256_set1_ps(inv_std);
        for (int c = c0; c < c1; c++) {
            const float gw = gn_w[c];
            const float gb = gn_b[c];
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;

            if (apply_silu) {
#if AHC061_EXP002_FAST_SILU == 0
                for (int i = 0; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    v = v * gw + gb;
                    dst[i] = silu(v);
                }
#else
                const __m256 vgw = _mm256_set1_ps(gw);
                const __m256 vgb = _mm256_set1_ps(gb);
                int i = 0;
                for (; i < kVec; i += 8) {
                    __m256 v = _mm256_loadu_ps(src + i);
                    v = _mm256_mul_ps(_mm256_sub_ps(v, vmean), vstd);
                    v = _mm256_fmadd_ps(v, vgw, vgb);
                    v = silu_avx2(v);
                    _mm256_storeu_ps(dst + i, v);
                }
                for (; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    v = v * gw + gb;
                    dst[i] = silu(v);
                }
#endif
            } else {
                const __m256 vgw = _mm256_set1_ps(gw);
                const __m256 vgb = _mm256_set1_ps(gb);
                int i = 0;
                for (; i < kVec; i += 8) {
                    __m256 v = _mm256_loadu_ps(src + i);
                    v = _mm256_mul_ps(_mm256_sub_ps(v, vmean), vstd);
                    v = _mm256_fmadd_ps(v, vgw, vgb);
                    _mm256_storeu_ps(dst + i, v);
                }
                for (; i < CELL_MAX; i++) {
                    float v = (src[i] - mean) * inv_std;
                    dst[i] = v * gw + gb;
                }
            }
        }
    }
}

__attribute__((target("avx2,fma")))
static void add_silu_inplace_avx2(float* x, const float* z, std::size_t n) {
#if AHC061_EXP002_FAST_SILU == 0
    for (std::size_t i = 0; i < n; i++) {
        x[i] = silu(x[i] + z[i]);
    }
#else
    std::size_t i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256 v = _mm256_add_ps(_mm256_loadu_ps(x + i), _mm256_loadu_ps(z + i));
        v = silu_avx2(v);
        _mm256_storeu_ps(x + i, v);
    }
    for (; i < n; i++) {
        x[i] = silu(x[i] + z[i]);
    }
#endif
}
#endif

static void add_silu_inplace(float* x, const float* z, std::size_t n) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        add_silu_inplace_avx2(x, z, n);
        return;
    }
#endif
    for (std::size_t i = 0; i < n; i++) {
        x[i] = silu(x[i] + z[i]);
    }
}

static void dwconv3x3(const float* in, int channels, const float* w, float* out) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        dwconv3x3_avx2(in, channels, w, out);
        return;
    }
#endif
    for (int c = 0; c < channels; c++) {
        const float* wc = w + static_cast<std::size_t>(c) * 9ULL;
        const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
        float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;
        for (int y = 0; y < N; y++) {
            dst[y] = dwconv3x3_cell(src, wc, 0, y);
            dst[(N - 1) * N + y] = dwconv3x3_cell(src, wc, N - 1, y);
        }
        for (int x = 1; x < N - 1; x++) {
            const int row = x * N;
            dst[row] = dwconv3x3_cell(src, wc, x, 0);
            for (int y = 1; y < N - 1; y++) {
                const int idx = row + y;
                dst[idx] = src[idx - N - 1] * wc[0] + src[idx - N] * wc[1] + src[idx - N + 1] * wc[2] +
                           src[idx - 1] * wc[3] + src[idx] * wc[4] + src[idx + 1] * wc[5] +
                           src[idx + N - 1] * wc[6] + src[idx + N] * wc[7] + src[idx + N + 1] * wc[8];
            }
            dst[row + (N - 1)] = dwconv3x3_cell(src, wc, x, N - 1);
        }
    }
}

static void group_norm(
    const float* in,
    int channels,
    int groups,
    const float* gn_w,
    const float* gn_b,
    float* out,
    bool apply_silu) {
#if AHC061_HAS_X86_AVX2_TARGET
    if (can_use_avx2()) {
        group_norm_avx2(in, channels, groups, gn_w, gn_b, out, apply_silu);
        return;
    }
#endif
    const int c_per_group = channels / groups;
    constexpr float kEps = 1.0e-5F;
    for (int g = 0; g < groups; g++) {
        const int c0 = g * c_per_group;
        const int c1 = c0 + c_per_group;
        float sum = 0.0F;
        float sq = 0.0F;
        for (int c = c0; c < c1; c++) {
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                const float v = src[i];
                sum += v;
                sq += v * v;
            }
        }
        const float inv_n = 1.0F / static_cast<float>(c_per_group * CELL_MAX);
        const float mean = sum * inv_n;
        float var = sq * inv_n - mean * mean;
        if (var < 0.0F)
            var = 0.0F;
        const float inv_std = 1.0F / std::sqrt(var + kEps);
        for (int c = c0; c < c1; c++) {
            const float gw = gn_w[c];
            const float gb = gn_b[c];
            const float* src = in + static_cast<std::size_t>(c) * CELL_MAX;
            float* dst = out + static_cast<std::size_t>(c) * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                float v = (src[i] - mean) * inv_std;
                v = v * gw + gb;
                dst[i] = apply_silu ? silu(v) : v;
            }
        }
    }
}

static void run_dwres_blocks(
    float* x,
    float* y,
    float* z,
    int channels,
    int blocks,
    int gn_groups,
    const float* dw_w,
    const float* dw_gn_w,
    const float* dw_gn_b,
    const float* pw_w,
    const float* pw_gn_w,
    const float* pw_gn_b) {
    const std::size_t ch = static_cast<std::size_t>(channels);
    for (int bi = 0; bi < blocks; bi++) {
        const std::size_t b_off_h = static_cast<std::size_t>(bi) * ch;
        const std::size_t b_off_dw = b_off_h * 9ULL;
        const std::size_t b_off_pw = b_off_h * ch;

        dwconv3x3(x, channels, dw_w + b_off_dw, y);
        group_norm(y, channels, gn_groups, dw_gn_w + b_off_h, dw_gn_b + b_off_h, y, true);

        conv1x1_rank1(y, channels, channels, pw_w + b_off_pw, z);
        group_norm(z, channels, gn_groups, pw_gn_w + b_off_h, pw_gn_b + b_off_h, z, false);

        add_silu_inplace(x, z, ch * CELL_MAX);
    }
}

static inline int infer_m_from_board(const std::array<float, FEATURE_INPUT_C * CELL_MAX>& board) {
    int best = 0;
    float best_v = board[static_cast<std::size_t>(R4_M2_ONEHOT_OFFSET) * CELL_MAX];
    for (int k = 1; k < 7; k++) {
        const float v = board[static_cast<std::size_t>(R4_M2_ONEHOT_OFFSET + k) * CELL_MAX];
        if (v > best_v) {
            best_v = v;
            best = k;
        }
    }
    const int m = best + 2;
    if (m < 2)
        return 2;
    if (m > M_MAX)
        return M_MAX;
    return m;
}

static void run_policy_logits(
    const CompactModel& model,
    const std::array<float, FEATURE_INPUT_C * CELL_MAX>& board,
    std::array<float, CELL_MAX>& out_logits) {
    std::array<float, HIDDEN_C * CELL_MAX> x_main;
    std::array<float, HIDDEN_C * CELL_MAX> y_main;
    std::array<float, HIDDEN_C * CELL_MAX> z_main;
    std::array<float, PLAYER_HIDDEN_C * CELL_MAX> common_proj;
    std::array<float, PLAYER_HIDDEN_C * CELL_MAX> py;
    std::array<float, PLAYER_HIDDEN_C * CELL_MAX> py_y;
    std::array<float, PLAYER_HIDDEN_C * CELL_MAX> py_z;
    std::array<float, PLAYER_BRANCH_N * PLAYER_HIDDEN_C * CELL_MAX> py_cat;

    conv1x1_rank1(board.data(), model.in_channels, model.hidden, model.main_stem_w.data(), y_main.data());
    group_norm(
        y_main.data(),
        model.hidden,
        model.gn_groups,
        model.main_stem_gn_w.data(),
        model.main_stem_gn_b.data(),
        x_main.data(),
        true);

    run_dwres_blocks(
        x_main.data(),
        y_main.data(),
        z_main.data(),
        model.hidden,
        model.front_blocks,
        model.gn_groups,
        model.main_front_dw_w.data(),
        model.main_front_dw_gn_w.data(),
        model.main_front_dw_gn_b.data(),
        model.main_front_pw_w.data(),
        model.main_front_pw_gn_w.data(),
        model.main_front_pw_gn_b.data());

    conv1x1_rank1(
        board.data(),
        PLAYER_COMMON_INPUT_C,
        model.player_hidden,
        model.player_stem_common_w.data(),
        common_proj.data());

    const int m = infer_m_from_board(board);
    const std::size_t ph = static_cast<std::size_t>(model.player_hidden);
    const std::size_t ph_plane = ph * CELL_MAX;
    for (int enemy = 0; enemy < PLAYER_BRANCH_N; enemy++) {
        float* dst_cat = py_cat.data() + static_cast<std::size_t>(enemy) * ph_plane;
        if (enemy + 1 >= m) {
            std::memset(dst_cat, 0, sizeof(float) * ph_plane);
            continue;
        }

        const int enemy_ch0 = R4_GLOBAL_C + (enemy + 1) * R4_PLAYER_PER_C;

        conv1x1_rank1(
            board.data() + static_cast<std::size_t>(enemy_ch0) * CELL_MAX,
            PLAYER_ENEMY_FEAT_INPUT_C,
            model.player_hidden,
            model.player_stem_enemy_w.data(),
            py.data());

        const float* id_bias = model.player_enemy_id.data() + static_cast<std::size_t>(enemy) * ph;
        for (std::size_t cidx = 0; cidx < ph; cidx++) {
            const float b = id_bias[cidx];
            float* ydst = py.data() + cidx * CELL_MAX;
            const float* csrc = common_proj.data() + cidx * CELL_MAX;
            for (int i = 0; i < CELL_MAX; i++) {
                ydst[i] += csrc[i] + b;
            }
        }
        group_norm(
            py.data(),
            model.player_hidden,
            model.player_gn_groups,
            model.player_stem_gn_w.data(),
            model.player_stem_gn_b.data(),
            py.data(),
            true);

        run_dwres_blocks(
            py.data(),
            py_y.data(),
            py_z.data(),
            model.player_hidden,
            model.front_blocks,
            model.player_gn_groups,
            model.player_front_dw_w.data(),
            model.player_front_dw_gn_w.data(),
            model.player_front_dw_gn_b.data(),
            model.player_front_pw_w.data(),
            model.player_front_pw_gn_w.data(),
            model.player_front_pw_gn_b.data());

        std::memcpy(dst_cat, py.data(), sizeof(float) * ph_plane);
    }

    conv1x1_rank1(x_main.data(), model.hidden, model.hidden, model.merge_main_w.data(), y_main.data());
    conv1x1_rank1(
        py_cat.data(),
        PLAYER_BRANCH_N * model.player_hidden,
        model.hidden,
        model.merge_player_w.data(),
        z_main.data());
    for (std::size_t i = 0; i < y_main.size(); i++) {
        y_main[i] += z_main[i];
    }
    group_norm(
        y_main.data(),
        model.hidden,
        model.gn_groups,
        model.merge_gn_w.data(),
        model.merge_gn_b.data(),
        y_main.data(),
        true);
    for (std::size_t i = 0; i < x_main.size(); i++) {
        x_main[i] += y_main[i];
    }

    run_dwres_blocks(
        x_main.data(),
        y_main.data(),
        z_main.data(),
        model.hidden,
        model.back_blocks,
        model.gn_groups,
        model.main_back_dw_w.data(),
        model.main_back_dw_gn_w.data(),
        model.main_back_dw_gn_b.data(),
        model.main_back_pw_w.data(),
        model.main_back_pw_gn_w.data(),
        model.main_back_pw_gn_b.data());

    policy_linear(x_main.data(), model.hidden, model.policy_w.data(), model.policy_b, out_logits.data());
}

static int select_action(
    const CompactModel& model,
    const std::array<float, FEATURE_INPUT_C * CELL_MAX>& board,
    const std::array<std::uint8_t, CELL_MAX>& mask) {
    std::array<std::uint8_t, CELL_MAX> legal{};
    int legal_n = 0;
    for (int idx = 0; idx < CELL_MAX; idx++) {
        if (mask[static_cast<std::size_t>(idx)]) {
            legal[static_cast<std::size_t>(legal_n++)] = static_cast<std::uint8_t>(idx);
        }
    }
    if (legal_n == 0) {
        return cell_index(0, 0);
    }
    std::array<float, CELL_MAX> logits;
    run_policy_logits(model, board, logits);
    int best = static_cast<int>(legal[0]);
    float best_v = -std::numeric_limits<float>::infinity();
    for (int li = 0; li < legal_n; li++) {
        const int idx = static_cast<int>(legal[static_cast<std::size_t>(li)]);
        const float v = logits[static_cast<std::size_t>(idx)];
        if (v > best_v) {
            best = idx;
            best_v = v;
        }
    }
    return best;
}

static inline void extract_features_selected_into(
    const State& st,
    int turn,
    const std::array<ParticleFilterSMC, M_MAX>* pf,
    const std::array<AdfBetaEstimator, M_MAX>* adf_beta,
    const std::array<std::int64_t, M_MAX>* precomputed_score_raw,
    NextMode next_mode,
    bool pf_enabled,
    float* out_board,             // [FEATURE_INPUT_C][100]
    std::uint8_t* out_action_mask, // [100]
    std::array<std::array<int, CELL_MAX>, M_MAX>& moves,
    std::array<int, M_MAX>& move_cnt,
    std::array<std::array<std::uint8_t, CELL_MAX>, M_MAX>& comp,
    std::array<std::array<std::uint8_t, CELL_MAX>, M_MAX>& reach
) {
    FeatureCommon common{};
    compute_feature_common_into(
        st,
        turn,
        pf,
        pf_enabled,
        common,
        out_action_mask,
        moves,
        move_cnt,
        comp,
        reach,
        next_mode,
        nullptr,
        adf_beta,
        precomputed_score_raw);
    write_features_from_common(common, out_board);
}

static inline void recompute_score_raw(const State& st, std::array<std::int64_t, M_MAX>& score) {
    score.fill(0);
    for (int idx = 0; idx < CELL_MAX; idx++) {
        const int o = static_cast<int>(st.owner[idx]);
        if (0 <= o && o < st.m) {
            score[static_cast<std::size_t>(o)] +=
                static_cast<std::int64_t>(st.value[idx]) * static_cast<std::int64_t>(st.level[idx]);
        }
    }
}

}  // namespace ahc061::exp002

int main() {
    using namespace std;
    using namespace ahc061::exp002;

    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 0, m = 0, t_max = 0, u_max = 0;
    if (!(cin >> n >> m >> t_max >> u_max))
        return 0;
    if (n != N) {
        cerr << "[ERROR] unexpected N=" << n << '\n';
        return 0;
    }
    if (m < 2 || m > M_MAX) {
        cerr << "[ERROR] unexpected M=" << m << '\n';
        return 0;
    }

    State st{};
    st.m = m;
    st.t_max = t_max;
    st.u_max = u_max;

    for (int x = 0; x < N; x++) {
        for (int y = 0; y < N; y++) {
            int v = 0;
            cin >> v;
            st.value[cell_index(x, y)] = v;
        }
    }

    for (int p = 0; p < m; p++) {
        int sx = 0, sy = 0;
        cin >> sx >> sy;
        st.ex[p] = static_cast<std::uint8_t>(sx);
        st.ey[p] = static_cast<std::uint8_t>(sy);
    }
    st.owner.fill(-1);
    st.level.fill(0);
    for (int p = 0; p < m; p++) {
        const int idx = cell_index(static_cast<int>(st.ex[p]), static_cast<int>(st.ey[p]));
        st.owner[idx] = static_cast<std::int8_t>(p);
        st.level[idx] = 1;
    }

    const std::uint64_t base_seed = compute_case_seed_for_pf(st);
    std::array<ParticleFilterSMC, M_MAX> pf{};
    std::array<AdfBetaEstimator, M_MAX> adf_beta{};
    std::array<std::int64_t, M_MAX> score_raw{};
    for (int p = 0; p < m; p++) {
        const std::uint64_t s = base_seed ^ (static_cast<std::uint64_t>(p + 1) * 0x9e3779b97f4a7c15ULL) ^ 0x243f6a8885a308d3ULL;
        pf[p].reset(s);
        adf_beta[static_cast<std::size_t>(p)].reset();
    }
    recompute_score_raw(st, score_raw);

    static_assert(static_cast<std::size_t>(FEATURE_INPUT_C) == kModelMeta_in_channels, "feature/model in_channels mismatch");
    const CompactModel model = load_compact_model();
    constexpr NextMode next_mode = NextMode::k_adf_beta;

    for (int turn = 0; turn < t_max; turn++) {
        const State st_start = st;

        std::array<float, FEATURE_INPUT_C * CELL_MAX> board{};
        std::array<std::uint8_t, CELL_MAX> mask{};
        std::array<std::array<int, CELL_MAX>, M_MAX> moves{};
        std::array<int, M_MAX> move_cnt{};
        std::array<std::array<std::uint8_t, CELL_MAX>, M_MAX> comp{};
        std::array<std::array<std::uint8_t, CELL_MAX>, M_MAX> reach{};
        extract_features_selected_into(
            st,
            turn,
            &pf,
            &adf_beta,
            &score_raw,
            next_mode,
            true,
            board.data(),
            mask.data(),
            moves,
            move_cnt,
            comp,
            reach);

        const int action_cell = select_action(model, board, mask);
        const int ax = action_cell / N;
        const int ay = action_cell % N;
        cout << ax << ' ' << ay << '\n' << flush;

        std::array<int, M_MAX> tx{};
        std::array<int, M_MAX> ty{};
        for (int p = 0; p < m; p++) {
            cin >> tx[p] >> ty[p];
        }

        for (int p = 1; p < m; p++) {
            const int c = cell_index(tx[p], ty[p]);
            const MoveSummary sum = summarize_ai_observation_from_moves(
                st_start,
                p,
                c,
                moves[static_cast<std::size_t>(p)].data(),
                move_cnt[static_cast<std::size_t>(p)]);
            adf_beta[static_cast<std::size_t>(p)].update(sum);
        }

        for (int p = 0; p < m; p++) {
            int ex = 0, ey = 0;
            cin >> ex >> ey;
            st.ex[p] = static_cast<std::uint8_t>(ex);
            st.ey[p] = static_cast<std::uint8_t>(ey);
        }

        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                int o = 0;
                cin >> o;
                st.owner[cell_index(x, y)] = static_cast<std::int8_t>(o);
            }
        }
        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                int l = 0;
                cin >> l;
                st.level[cell_index(x, y)] = static_cast<std::uint8_t>(l);
            }
        }
        recompute_score_raw(st, score_raw);
    }

    return 0;
}
